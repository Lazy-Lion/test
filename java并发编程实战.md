#### Word List: 
 - civil engineering 土木工程
 - rivet 铆钉
 - I-beam 工字梁
 - fall down 失败；倒塌
 - means to an end 达到目的的手段
 - externally 外部地；外表上
 - coordinate v.调节； n.坐标； adj.坐标的
 - corruption 贪污；腐败；堕落
 - mechanism 机制；原理
 - temptation 引诱；诱惑物
 - omit 省；，疏忽
 - trival 不重要的；琐碎的
 - retrofit 改进；更新
 - maintainable 可维护的
 - encapsulation 封装
 - invariant n.不变量；adj.不变的
 - at odds with 与..争执；意见不一致
 - compromise 妥协
 - sake 目的；利益；理由
 - compatibility 兼容性
 - legacy 遗产；遗留问题
 - not nearly 远非
 - pursue 继续；追赶；纠缠
 - realistic 现实的
 - adhere 坚持；依附；追随
 - dwarf adj.矮小的；v.变矮；n.矮子，侏儒
 - fragile 脆的，易碎的
 - characterize 描绘..特性；塑造人物
 - interchangeably 可交换地
 - thus far 迄今，现在为止
 - composition 作文；作曲；作品；构成；合成物；成分
 - make sense 有意义
 - make sense of 搞清..的意思
 - make sense to 对..合乎情理；有意义
 - make sense for 对..有意义
 - make sense out of 弄明白；理解
 - in a sense 在某种意义上
 - tricky 狡猾的；机警的；棘手的
 - intuitive 直觉的
 - counterintuitive 违反直觉的
 - downright 向下；完全地；(坏事)彻头彻尾的；(人的举止或行为)直率的；径直前进的
 - numerous 许多的
 - turn up 出现
 - no wonder 难怪
 - interaction 交互
 - suspiciously 怀疑地；猜测地
 - fuzzy 模糊的；失真的
 - conform 符合
 - constrain 约束
 - adequate 充足的；适当的；胜任的
 - convince 确信
 - interleave 交错；交叉
 - regardless of 不管；不顾
 - violate 违反；妨碍；侵犯
 - post-conditions 后置条件
 - stem from 起源于
 - facility 设施；设备；才能；天赋
 - factorization 因式分解
 - preserve 保留；保存
 - transient 短暂的
 - solely 单独地；仅仅
 - burden 负担
 - susceptible 易受影响的；敏感的
 - compact 袖珍的；紧凑的
 - indivisible 不可分割的
 - shorthand 速记
 - discrete 离散的；不连续的
 - derive from 源于
 - simultaneously 同时地
 - permanently 永久地
 - integrity 完整；正直；诚实
 - presence 存在；出席
 - arise 出现；发生
 - stand up 坚持；拥护；站得住脚
 - frustrated 沮丧的
 - nip 夹；捏；剪断；冻伤；阻止
 - idiom 习语
 - defer 推迟
 - undermine 破坏
 - vagary n.变换莫测
 - compound n.化合物，混合物；adj.混合的；v.合成，混合，恶化，和解，妥协
 - with respect to 相对于
 - prespective n.视角，远景，透视图；adj.透视的
 - either or 两者择一的
 - neither nor 既不是..也不是
 - neither of 没有一个
 - refer 涉及；参考；查阅
 - collectively 集体地；共同地
 - necessarily 必要地；必然地；必定地
 - arbitrary 任意的；武断的；专制的
 - reason about 推出
 - consecutive 连续的
 - vulnerability 易损性；弱点
 - span v.跨越;n.跨度
 - guard 保卫；看守
 - mutual 共同的
 - intrinsic 本质的；固有的
 - fairly 相当地；公平地
 - extreme adj.极端的；n.极端
 - inhibit 阻止
 - be addressed 得到解决
 - basis 基础
 - acquisition 获得
 - stall n.货摊，畜栏，（房间内的）小隔间，车位，（车辆）熄火，（飞机）失速；v.熄火，拖延，暂缓
 - inherent 固有的；内在的；与生俱来的
 - convention 大会；惯例；约定；协定；习俗
 - throughout 自始至终；遍及
 - retrospect 回顾
 - tradeoff 权衡；折衷；（公平）交易
 - subvert 颠覆；推翻；破坏
 - audit 审计
 - ripple 波纹；涟漪
 - periodic 周期的；定期的
 - cure v.治疗，解决（问题）；n.药物，治疗
 - indiscriminate 任意的；无差别的
 - merely 仅仅，只不过
 - render v.致使，提供，提出，渲染
 - coarse-grained 粗鲁的；木纹粗糙的；粗略的；大概的
 - intend 打算
 - idle 闲置的
 - bonus 奖金；红利
 - constitute 构成；任命
 - portion n.部分；v.将..分配
 - revert 重新提到；回复
 - overhead n.经常性支出；adv.在头顶上方，在空中；adj.（费用开支等）日常的，在空中的
 - unduly 过度地；不适当地
 - tension n.张力，拉力，紧张，电压；v.使紧张，使拉紧
 - resist v.抵抗，忍耐；n.抗蚀剂
 - prematurely 过早地
 - sacrifice 牺牲
 - misconception 误解
 - demarcate 划分界线；区别
 - subtle 微妙的；精细的
 - intervene v.介于；adj.介于中间的
 - phenomenon 现象；奇迹；杰出人才
 - apparent 显然的；表面上的
 - in the absence of 缺少..时
 - weird 怪异的；不可思议的
 - insufficiently 不足地；不能胜任地
 - prohibitively 禁止地；过分地
 - scary 可怕的
 - stale 陈旧的
 - all or nothing 孤注一掷的；全部或一无所有的
 - edible adj.可食用的；n.食品
 - prevent 阻止；妨碍
 - analogous 类似的
 - hazard n.危害；v.使冒危险
 - out of thin air 无中生有地
 - prior 优先的
 - alternative 供选择的
 - propagate 传播；宣传；繁殖
 - roughly 大致；粗略地
 - anthropomorphized  给..赋予人性
 - cumbersome 笨重的
 - hoist v.升高，举起；n. 提升，起重
 - blatant 喧嚣的；公然的；炫耀的；显眼的
 - indirectly 间接地
 - abbreviation 缩写
 - misuse 误用
 - maliciously 有敌意地；恶意地
 - carelessly 粗心地
 - compelling 引人注目的；令人信服的；不可抗拒的
 - compel v.强迫
 - steal 偷窃
 - mischief 恶作剧；伤害
 - confinement 限制
 - swing n.摇摆，秋千；adj.旋转的，悬挂的，强节奏爵士音乐的；v.摇摆，转向，悬挂
 - extensively 广阔地；广泛地
 - dispatch 派遣；发送
 - other than 除了
 - dispense 分发；免除
 - enforce 实施；执行；强制
 - responsibility 责任；义务
 - responsiveness n.响应能力，有同情心
 - even with 即使有
 - outweight 比..重要
 - sparingly 节俭地；保守地；爱惜地
 - primitively 最初地；原始地
 - associate v.联系，关联；n.伙伴，联想；adj.联合的，副的
 - straightforward 简单的；直截了当地
 - mundane 平凡的；世俗的；宇宙的；世界的
 - consult 请教；咨询
 - conceptually 概念上
 - port n.港口，口岸，端口，舱门，左舷；v.持（枪），左转舵
 - abuse 滥用
 - property 性质；性能；财产；所有权
 - detract 贬低；减去；转移；使分心
 - reusability 可重用性
 - couple n.对，夫妇；v.结合，连接，成婚
 - buggy 多虫的
 - delicate 微妙的；精美的；可口的
 - benign 良性的；和蔼的；吉利的
 - unwarranted 无根据的；无保证的
 - eliminate 消除，排除
 - interfere 干涉；妨碍；冲突；介入
 - harmless 无害的；无恶意的
 - immune adj.免疫的，免于..的；n.免疫者
 - entail 需要
 - for the moment 暂时；暂且；目前
 - fulfill 满足
 - engagement 婚约；约会；诺言；参与度
 - compose 组成；构成；作曲；写作
 - comprise 包含，由..组成
 - encompass 包含；环绕
 - take on 承担
 - derive 源于；导出
 - impose 强加；利用
 - transition 过渡；转变
 - underlying 潜在的；根本的
 - obey 服从
 - precondition 先决条件
 - tightly 紧紧地
 - implied 暗指的；隐式的 
 - embody 体现；具体表达
 - ownership 所有权
 - short-term 短期的
 - long-term 长期的
 - loan n.贷款；v.借
 - envision 想象；预想
 - joint adj.联合的，合办的，共同拥有的；n.关节，接合处，（非正式）娱乐场所；v.连接
 - precise 精确的；严格的
 - exhibit n.展览品，展览会，证据；v.展览，提出（证据等）
 - infrastructure 基础设施；公共建设
 - safekeep 保护
 - passivation 钝化处理
 - discipline n.学科，纪律，训练，惩罚；v.训练，惩戒
 - so long as 只要
 - inspire 激发；鼓舞
 - sophisticated 复杂的；久经世故的
 - scalability 扩展性
 - widget 装饰品；小部件
 - fleet adj.快速的，敏捷的，（水）浅的；n.船队，舰队，海军，车队，小河，水道，沟；v.（诗歌或文学）飞逝，疾驰，使（时间）飞快地过去，消失，转瞬即逝 
 - concise 简明的
 - taxicab 出租车
 - manually 手动地
 - drawback 缺点，不利条件，退税
 - degrade 降低
 - scratch n.擦伤，抓痕；v.抓，刮，乱涂；adj.打草稿用的，凑合的
 - substantial adj.大量的，实质的；n.本质，重要材料
 - liability 责任；债务；倾向；可能性；不利因素
 - shallow n.浅滩；adj.浅的，肤浅的；v.变浅
 - accommodate 容纳；适应；调解
 - at once 立刻；马上
 - building block 积木；构件
 - effort 努力；成就
 - bell n.铃；v.系铃
 - warning bell 警铃
 - go off 离开；爆炸；动身
 - interpretation 解释；翻译；演出
 - facilitate 促进；帮助；使容易
 - comprehension n.理解；包含
 - admit 承认；容许
 - subtly 精细地；巧妙地
 - suffer from 忍受；遭受
 - functionality 功能；函数性
 - illusion 幻觉；错觉
 - albeit 虽然；尽管
 - obliquely 倾斜地；转弯抹角地
 - penalty 罚款；罚金；处罚
 - mimic v.模仿；adj.模仿的；n.模仿者
 - outstanding 杰出的；显著的；未解决的
 - contend 竞争；斗争；争论；主张
 - underutilize 未充分利用
 - inadvertently 无意地；不经意地
 - constituency 选民；支持者
 - blur v.变模糊；沾上污迹；n.模糊不清的事物；污迹
 - craft n.工艺，太空船；v.精巧地制作
 - affair 事情；绯闻；私事
 - clue n.线索；v.为..提供线索
 - woefully 悲伤地；不幸地
 - prudence n.审慎，谨慎
 - ought to 应该
 - intuition 直觉
 - neglect n.忽视，忽略；v.忽视，忽略
 - erroneous 错误的；不正确的
 - vague 模糊的
 - forthcoming n.来临；adj.即将来临的
 - vendor 卖主；小贩；供应商；自动售货机
 - compliant 顺从的；服从的；应允的
 - frustratingly 令人泄气地；令人沮丧地
 - omission 省略
 - despite prep.即使，尽管；n.侮辱，轻视
 - revision 修订本
 - as opposed to 与..截然相反；对照
 - merely 仅仅
 - absurd n.荒诞，荒诞作品；adj.荒谬的，可笑的
 - bolster v.支持，支撑，改善，给（座位）加软垫；n.垫枕，托木，支持
 - replication 复制；回答；反响
 - take responsibility for 对..负责
 - exhausted adj.精疲力尽的，耗尽的；v.使..精疲力尽，耗尽
 - navigation 航行；航海
 - corrupt adj.腐败的，堕落的；v.腐烂，堕落
 - opinion 意见；主张
 - shrink v.收缩；缩小，退缩，（衣服）缩水；n.心理医生，收缩，畏缩
 - leap v.跳跃，猛冲，剧增；n.跳跃，剧增
 - in conformance with 与..一致；符合
 - impair 损害；削弱；减少
 - clarity 清楚；明晰；透明
 - obviate 排除；避免
 - foolproof 极简单的
 - indicator 指示器；指示灯
 - deliberate adj.故意的，深思熟虑的，从容的；v.仔细考虑，商议
 - starvation 饿死；挨饿；绝食
 - throughput 吞吐量
 - utilization 利用率；利用
 - favorable 有利的；良好的；赞成的
 - bold 大胆的；英勇的；黑体的；险峻的
 - concatenation 连接；串联
 - dominant 占优势的；统治的
 - retrieval n.检索，取回，恢复，拯救
 - spread out 展开；传播
 - unevenly 不均衡地；不平坦地
 - degenerate v.退化，恶化，堕落；adj.退化的，堕落的；n.堕落的人
 - strip v.脱去衣服，剥去（外皮），拆卸，剥夺，修剪（树枝）；n.条状物，脱衣舞，（纸、金属、织物等）带
 - along with 沿着；与..一道
 - estimate 估计；评估
 - approximation 近似值
 - continuously 连续不断地
 - drop-in adj.不用预约的，立即使用的；n.非正式造访，不速之客
 - briefly 短暂的；简略的；暂时的
 - criterion （批评判断的）标准；准则；规范
 - deliver 发表；投递；释放
 - as well as 也；和..一样
 - equivalent n.对等的人，当量；adj.等价的
 - workload 工作量
 - rate n.比率，速度，价格，等级；v.认为，估价，责骂，被评价 
 - labor n.劳动，工作，分娩；v.劳动，努力，使厌烦，详细分析 
 - rack n.架子，拷问台，齿条；v.变形，折磨，榨取，小步跑 
 - dry adj.干的，口渴的；n.干涸；v.变干
 - fill up 装满
 - analogy n.类比，类推
 - sink v.下沉；n.水槽
 - crawler 爬行者；爬虫
 - eventually 最后；终于
 - catch up 赶上；追上
 - shed n.小屋，棚，分水岭；v.流出，脱落，散布
 - excess adj.额外的，过量的；n.超过，过度
 - throttle n.节流阀，喉咙；v.节流，窒息
 - robust 强健的；粗野的
 - threaten 威胁；恐吓
 - keep up 保持；继续；不落后
 - rearchitect 重构
 - up front 预先
 - feed back 反馈
 - amenable 有责任的；有义务的；顺从的；经得起检验的
 - decomposition n.分解，腐烂，变质
 - agent n.代理人，代理商，特工 ；v.由..代理，由..作中介；adj.代理的
 - hierarchy 层级；等级制度
 - monolithic adj.整体的，庞大的；n.单片电路
 - yield v.生产；产出，屈服，放弃，停止争论，给..让路；n.产量，利润
 - overall adj.全部的；adv.总的来说；n.工装裤，罩衫
 - exploit n.功绩；v.开发，开采，剥削
 - eligible n.合格者，有资格者；adj.合格的，符合条件的
 - sensible 明智的；合乎情理的
 - get away with 侥幸成功
 - deprive 使丧失，剥夺
 - swallow v.忍受，吞没，咽下；n.燕子，一次吞咽的量
 - in bulk 整批；散装；大批；大量
 - gate n.大门，出入口，门道；v.给..装大门
 - bother with 为..费心；用..打扰
 - presumably 大概；推测起来；可假定
 - vary v.改变；变化；违反；使多样化
 - bear v.忍受，承受，不适于某事，承担责任，经得起，坏心情，支持，携带，生（孩子），产生（利息）；n.熊，泰迪熊
 - subsume 把..归入；把..包含在内
 - convey 传达；运输
 - lengthy 漫长的；冗长的；啰嗦的
 - inadvisable 失策的；不明智的
 - coerce 强制；迫使
 - rendezvous n.约会，约会地点，集结地；v.会合，约会，在指定地点与..相会
 - elect v.选举，选择，决定（做某事）；adj.卓越的，当选（而尚未就职的）的；n.被选的人
 - trip n.旅行，赛程，绊倒，错误，（机器、电路的）开关，奇妙有趣的经历；v.绊倒，（部分电路）自动断开，触发（开关）
 - particle 颗粒；[物]质点；极小量
 - cellular n.移动电话，单元；adj.细胞的，多孔的
 - automata 自动机；不动脑筋机械行事的人；自动装置；小机器人（automaton的复数）
 - asymmetric 不对称的
 - bottleneck 瓶颈；障碍物

Writing thread-safe code is about managing access to **shared, mutable** state.


> java synchronization：

 - synchronized keywords： provide exclusive locking 
 - volatile variables
 - Explicit Lock
 - atomic variables

> if multiple threads access the same mutable state variable without appropriate synchronization, your program is broken. There are three ways to fix it: 

  - Don't share the state variable across thread;
  - Make the state variable immutable
  - Use synchronization whenever accessing the state variable
  

> Practice:

  It is always a good practice first to make your code right, and then make it fast. Even then, pursue optimization only if you performance measurements and requirements tell you that you must, and if those some measurements tell you that your optimization actually made a difference under realistic conditions.

a program that consists entirely of thread-safe class may not be thread-safe, and a thread-safe classes may contain classes that are not thread-safe.


> Thread-safe class:

 A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordinationon the part of the calling code. <br />

 No set of operations performed sequentially or concurrently on instances of a thread-safe class can cause an instance to be in an invalid state. <br />

 Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.

 Stateless objects are always thread-safe.

> Race Conditions

  A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime; in other words, when gettig the right answer relieson lucky timing. <br />

  The most common type of race condition is check-then-act, where a potentially stale observation is used to make a descision on what to do next.<br />

  To ensure thread safety, check-then-act operations (like lazy initialization) and read-modify-write operations (like increment) must always be atomic.

( **data race: arises when synchronization is not used to coordinate all access to a shared non-final field. Not all race conditions are data races, and not all data races are race conditions, but they both can cause concurrent programs to fail in unpredictable ways.** )

> synchronized:

``` java
  synchronized (lock) {
    // body 
  }
```
synchronized block has two parts:

 - a reference to an object that will serve as the lock (Synchronized method's lock is the object on which the mehtod is being invoked. Static synchronized methods use the Class object for the lock.)
 - a block of code to be guarded by that lock (synchronized method spans an entire method body)

> Intrinsic locks 

  Every Java object can implicitly act as a lock for purposes of synchronization; these built-in locks are called intrinsic locks or monitor locks. The lock is automatically acquired by the executing thread before entering a synchronized block and automatically released when control exits the synchronized block, whether by the normal control path or by throwing an exception out of the block.The only way to acquire an intrinsic lock is to enter a synchronized blcok or method guarded by that lock. <br />

  Intrinsic locks in Java act as mutexes (or mutual exclusion locks), which means that at most one thread may own the lock.<br />

  Intrinsic locks are reentrant, if a thread tries to acqire a lock that it already holds, the request succeeds.

> Serialized access:

  Serialized acess to an object has nothing to do with object serialization; serialized access means that threads take turns accessing the object exclusively, rather than doing so concurrently.

Every shared, mutable variable should be guarded by exactly **one lock**.

There is frequently a tension between simplicity and performance.When implementing a synchronization policy, resist the temptation to prematurely sacrifice simplicity (potentially compromising safety) for the sake of performance.

Avoid holding locks during lengthy computations or operations at risk of not completing quickly such as network or console IO.

> Memory Visibility 

In order to ensure visibility of memory writes across threads, you must use synchronization.

> Reordering

There is no guarantee that operations in one thread will be performed in the order given by the program, as long as the reordering is not detectable from within that thread - even if the reordering is apparent to other threads.

> The Java Memory Model requires fetch and store operations to be atomic, bur for nonvolatile long and double variables, the JVM is permitted to treat a 64-bit read or write as two separate 32-bit operations.If the reads and writes occur in different threads, it is therefore possible to read a nonvolatile long and get back the high 32 bits of one value and the low 32 bits of another.

> Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all thread see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lcok.

> Volatile Variables 

When a field is declared volatile, the compiler and runtime are put on notice that this variable is shared and that operations on it should not be reordered with other memory operations.Volatile variables are not cached in registers or in caches where they are hidden from other processors, so a read of a volatile variable always returns the most recent write by any thread.<br />

Yet accessing a volatile variable perfroms no locing and so cannot cause the executing thread to block, making volatile variables a lighter-weight synchronization mechanism than synchronized. (Volatile reads are only slightly more expensive than nonvolatile reads on most current processor architectures.) <br />

Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when verifying correctness would require subtle reasoning about visibility. Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event(such as initialization or shutdown) has occurred. <br />

Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.<br />

You can use volatile variables only when all the following criteria are met:

- Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;
- The variable does not participate in invariants with other state variables;
- Locing is not required for any other reason while the variable is being accessed.

> Publication and Escape

Publishing an object means making it available to code outside of its current scope, such as by storing a reference to it where other code can find it, returning it from a non-private method, or passing it to a method in another class.<br />

An object that is published when it should not have been is said to have escaped.<br />

An object is in a predictable, consistent state only after its constructor returns, so publishing an object from within its constructor can publish an imcompletely constructed object. This is true even if the publication is the last statement in the constructor. If the this reference escapes during construction, the object is considered not properly constructed.<br />

When an object create a therad from its constructor, it almost always shares its this reference with the new thread, either explicitly (by passing it to the constructor) or implicitly (because the Thread or Runnable is an inner class of the owing object). The new Thread might then be able to see the owning object before it is fully constructed. There is noting wrong with creating a thread in a consturctor, but it is best not to start the thread immediately. Instead, expose a start or initialize method that starts the owned thread.Calling an overrideable instance method (one that is neither private nor final) from the constructor can also allow the this reference to escape.

> Thread Confinement

If data is only accessed from a single thread, no synchronization is needed.When an object is confined to a thread, such usage is automatically thread-safe even if the confined object itself is not.This technique, thread confinement, is one of the simplest ways to achieve thread safety.<br />

- Ad-hoc Thread Confinement: Ad-hoc thread confinement describes when the responsibility for maintaining thread confinement falls entirely on the implementation.Ad-hoc thread confinement can be fragile because none of the language features, it should be used sparingly.
- Stack Confinement: An object can only be reached through local variables.Maintaining stack confinement for object references requires a little more assistance from the programmer to ensure that the referent does not escape.
- ThreadLocal: Allows you to associate a per-thread value with a value-holding object. The thread-specific values are stored in the Thread object itself, when the thread terminates, the thread-specific values can be garbage collected.

``` java
 private static ThreadLocal<Connection> connectionHolder =
   new ThreadLocal<Connection>(){
       public Connection initialValue(){ 
       // when a thread calls ThreadLocal.get for the first time, initialValue is consulted to provide the initial value for that thread.
           return DriverManager.getConnection(DB_URL);
       }
   };

 public static Connection getConnection() {
    return connectionHolder.get();
 }
```

> Immutability 

An immutable object is one whose state cannot be changed after construction. Immutable objects are inherently thread-safe; their invariants are established by the consturctor, and if their state cannot be changed, these invariants always hold.

An object is immutable if: 

- Its state cannot be modified after construction
- All its field are final (It is technically possible to have an immutable object without all fields being final. java.lang.String lazily computes the hash code the first time hashCode is called and caches it in a non-fianl field, but this work only because that field can take on only one non-default value that is the same every time it is computed because it is derived deterministically from immutable state.)
- It is properly constructed (the this reference does not escape during construction)

 ```java
 public int hashCode() { 
 // hash的计算推迟到第一次调用hashCode(),基于final域value,每次计算结果都相同
   int h = hash; 
   if (h == 0 && value.length > 0) {
     char val[] = value;
     for (int i = 0; i < value.length; i++) {
       h = 31 * h + val[i];
     }
     hash = h;
   }
   return h;
 }
 ```

> Final Fields

Final fields cannot be modified (although the objects they refer to can be modified if they are mutable), but they also have special semantics under the Java Memory Model. It is the use of final fields that makes possible the guarantee of initialization safety that lets immutable objects be freely accesssed and shared without synchronization.<br />

Just as it is a good practice to make all fields private unless they need greater visibility, it is a good practice to make all fields final unless they need to be mutable.

> safe publication

``` java
// unsafe publication
public Holder holder;

pubic void initialize() {
    holder = new Holder(42);
}
```

Two things can go wrong with improperly published objects.Other threads could see a stale value for the Holder field, and thus see a null reference or other older value even though a value has been placed in Holder (While it may seem that field values set in a constructor are the first values written to those fileds and therefore that there no "older" values to see stale value, the Object constructor first writes the default values to all fields before subclass construcotrs run. It is therefore possible to see the default value for a field stale value.).

> Immutable Objects and Initialization Safety

Because immutable objects are so important, the java Memory Model offers a special guarantee of initialization safety for sharing immutable object. An object reference becomes visible to another thread does not necessarily mean that the state of that object is visible to the consuming thread. In order to guarantee a consistent view of the object's state, synchronization is needed.<br />

Immutable objects can be safely accessed even when synchronization is not used to publish the object reference. For this guarantee of initialization safety to hold, all of the requirements for immutability must be met: unmodifiable state, all fields are final, and proper construction. <br />

Immutable objects can be used safely by any thread without additional synchronization, even when synchronization is not used to publish them.<br />

This guarantee extends to the values of all final fields of properly constructed objects; final fields can be safely accessed without additional synchronization. However, if final fields refer to mutable objects, synchronization is still required to access the state of the objects they refer to.

> Safe Publication Idioms

To publish an object safely, both the reference to the object and the object's state must be made visible to other threads at the same time. A properly constructed object can be safely published by:

- Initializing an object reference from static initializer;
- Storing a reference to it into a volatile field or AtomicReference;
- Storing a reference to it into a final field of a properly constructed object
- Storing a reference to it into a field that is properly guarded by a lock

> Effectively Immutable Objects

Objects that are not technically immutable, but whose state will not modified after publication, are called effectively immutable.<br />

Safely published effectively immutable objects can be used safely by any thread without additional synchronization.

> Mutable Objects

To share mutable objects safely, they must be safely published and be either thread-safe or guarded by a lock. <br />

The publication requirements for an object depend on its mutability:

- Immutable objects can be published through any mechanism
- Effectively immutable objects must be safely published
- Mutable objects must be safely published, and must be either thread-safe or guarded by a lock.

> Sharing Objects Safely 

The most useful policies for using and sharing objects in a conucrrent program are: 

- Thread-confined. A thread-confined object is owned exclusively by and confined to one thread, and can be modified by its owning thread.
- Shared read-only. A shared read-only object can be accessed concurrently by multiple threads without additional synchronization, but cannot be modified by any thread. Shared read-only objects include immutable and effectively immutable objects.
- Shared thread-safe. A thread-safe object performs synchronization internally, so multiple threads can freely access it through its public interface without further synchronization.
- Guarded. A guarded object can be accessed only with a specific lock held. Guarded objects include those that are encapsulated within other thread-safe objects and pubished objects that are known to be guarded by a specific lock.


> Instance Confinement 

If an object is not thread-safe, several techniques can still let it be used safely in a multithreaded program. You can ensure that it is only accessed from a single thread (thread confinement), or that all access to it is properly guarded by a lock.<br />

Encapsulating data within an object confines access to the data to the object's methods, make it easier to ensure that the data is always accessed with the appropriate lock held.<br />

Confined objects must not escape their intended scope. An object may be confined to a class instance (such as a private class member), a lexical scope (such as a local variable), or a thread (such as an object that is passed from method to method within a thread, but not supposed to be shared across threads.)

> The Java Monitor Pattern

```java
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;

    void someMethod() {
        synchronized (myLock) {
            // access or modify the state of widget
        }
    }
}
```

Making the lock object private encapsulates the lock so that client code cannot acquire it, whereas a publicly accessible lock allows client code to participate in its synchronization policy - correctly or incorrectly.


``` java
@NotThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    // it synchronizes on wrong lock, use different locks
    public synchronized boolean putIfAbsent (E x) {
        boolean absent = !list.contains(x);
        if (absent) {
            list.add(x);
        }
        return absent;
    }
} 
```

```java 
@ThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public boolean putIfAbsent (E x) {
        synchronized (list) {
          boolean absent = !list.contains(x);
          if (absent) {
              list.add(x);
          }
          return absent;
        }
    }
}
```

```java
@ThreadSafe
public class ImporvedList<T> implements List<T> {
    private final List<T> list;

    public ImporvedList(List<T> list) { this.list = list; }

    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (!contains) {
            list.add(x);
        }
        return !contains;
    }

    public synchronized void clear() {
        list.clear();
    }
}
```

> Synchronized Collections: Vector, Hashtable, synchronized wrapper class created by the Collections.synchronizedXXX factory methods. These classes achieve thread safety by encapsulating their state and synchronizing every public method so that only one thread at a time can access the collection state. 

Synchronized Collections achieve their thread safety by serializing all access to the collection's state. The cost of this approach is poor concurrency; when multiple threads contend for the collection-wide lock, throughput suffers.


> Iterator and ConcurrentModificationException 

fail-fast: if they detect that the collection has changed since iteration began, they throw the unchecked ConcurrentModificationException. They are implemented by associating a modification count with the collection: if the modification count changes during iteration, hasNext() or next() throws ConcurrentModificationException.However, this check is done without synchronization, so there is a risk of seeing a stale value of the modification count and therefore that the iterator does not realize a modification has been made. This was a deliberate design tradeoff to reduce the performance impact of the concurrent modification detection code.<br />

(**在单线程代码中也可能抛出ConcurrentModificationException异常，当对象直接从容器中删除而不是通过Iterator.remove()来删除时就会抛出该异常。<remove()方法会修改exceptedModCount的值>**) <br />

The way to prevent ConcurrentModificationException:

- hold the collection lock for the duration of the iteration
- clone the collection and iterate the copy instead (The collection still must be locked during the clone operation itself.)<br />

Iteration is indirectly invoked by the collection's hashcode, equals and toString methods, which may be called if the collection is used as an element of key of another collection. Similarly, the containsAll, removeAll, and retainAll methods, as well as the constructors that take collections are arguments, also iterate the collection. All of these indirect uses of iteration can cause ConcurrentModificationException.

> Concurrent Collections: 

- ConcurrentHashMap: a replacement for synchronized hash-based Map implementation. 
  
   ConcurrentHashMap, along with the other concurrent collections, further improve on the synchronized collection classes by providing iterators that do not throw ConcurrentModificationException, thus eliminating the need to lock the collection during iteration. The iterators returned by ConcurrentHashMap are weakly consistent instead of fail-fast. <br />

   A weakly consistent iteartor can tolerate concurrent modification, traverses elements as they existed when the iterator was constructed, and may (but is not guarantee to) reflect modifications to the collection after the construction of the iterator.<br />



    jdk 7 : segment 实现，对整个Map进行计算的方法语义进行弱化，如size返回的结果可能已经过期，实际上只是个估计值；<br /> 
    jdk 8 : CAS，synchronized 实现<br />

    [为并发而生的 ConcurrentHashMap（Java 8）](https://www.jianshu.com/p/e99e3fcface4)<br />
    [为什么ConcurrentHashMap的读操作不需要加锁？](https://juejin.im/entry/5b98b89bf265da0abd35034c)

- ConcurrentSkipListMap: a replacement for a synchronized SortedMap

- ConcurrentSkipListSet: a replacement for a synchronized SortedSet

- CopyOnWriteArrayList: a replacement for synchronized List implementations for cases where traversal is the dominant operation.
    
    They implement mutability by creating and republishing a new copy of the collection every time it is modified. Iterators for the copy-on-write collections retain a reference to the backing array that was current at the start of iteration, and since this will never change, they need to synchronize only brieflyto ensure visibility of the array contents. The iteartors returned by the copy-on-write collections do not throw ConcurrentModificationException and return the elements exactly as they were at the time the iterator was created, regardless of subsequent modifications.<br />

    The copy-on-write collections are reasonable to use only when iteration is far more common than modification.

- ConcurrentMap： new interface, adds support for common compound actions such as put-if-absent, replace, and conditional remove.<br />

- Queue: is intended to hold a set of elements temporarily while they await processing. Queue operations do not block; if the queue is empty, the retrieval operation returns null.

- ConcurrentLinkedQueue: a traditional FIFO queue

- PriorityQueue: a (non concurrent) priority ordered queue

- BlockingQueue: extends Queue to add blocking insertion and retrieval operations. If the queue is empty, a retrieval blocks until an element is available, and if the queue is full (for bounded queues) an insertion blcoks until there is space available. Blocking queues are extremely useful in producer-consumer design.

- BlockingQueue and producer-consumer

```java
/* Inserts the specified element into this queue, waiting if necessary for space to become available. */
    void put(E e) throws InterruptedException;
    
/* Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. */    
    E take() throws InterruptedException;
```

| Implements | Detail |
| - | - |
| ArrayBlockingQueue | FIFO，有界 |
| LinkedBlockingQueue | FIFO，有界或无界 |
| PriorityBlockingQueue | 有界，process elements in priority-ordered other than FIFO, can compare elements according to their natural order (if they implement Comparable) or using Comparator. |
| SynchronousQueue | in that it maintains no storage space for queued element. Instead, it maintains a list of queued threads waiting to enqueue or dequeue an element. SynchronousQueue has no storage capacity, put and take will block unless another thread is already waiting to partcipate in the handoff. Synchronous queues are generally suitable only when there are enough consumers that there nearly always will be one ready to take the handoff. Executors.newCachedThreadPool() use this queue. |

队列可以是有界的，也可以是无界的，无界队列永远不会充满，因此无界队列上的 put 永远不会阻塞(通常这种无界不是真的无界，而是容量是Integer.MAX_VALUE)。
<br />
[解读 Java 并发队列 BlockingQueue](https://javadoop.com/2017/08/22/java-concurrent-queue/?)

**在构建高可用的应用程序时，有界队列是一种强大的资源管理工具，它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。**

- Deque (pronounced "deck") and BlockingDeque: extend Queue and BlockingQueue.

A Deque is a double-ended queue that allows efficient insertion and removal from both the head and the tail. Implementations include ArrayDeque and LinkedBlockingDeque. <br />

Work Stealing: A producer-consumer design has one shared work queue for all consumers; in a word stealing design, every consumer has its own deque. If a consumer exhausts the work in its own deque, it can steal work from the tail of someone else's deque. Work stealing can be more scalable than a traditional producer-consumer design because workers don't contend for a shared work queue; most of the time they access only their own deque, reducing contention. When a worker has to access another's queue, it does so from the tail rather than the head, further reducing contention. <br />

Work stealing is well suited to problems in which consumers are also producers - when performing a unit of work is likely to result in the identification of more work.

> Blocking and Interruptible Methods 

Threads may block or pause for serveral reasons: 

- waiting for I/O completion 
- waiting to acquire a lock
- waiting to wake up from Thread.sleep
- waiting for the result of a computation in another thread

When a thread blocks, it is usually suspended and palced in one of the blocked thread states (BLOCKED, WAITING, or TIMED_WAITING). <br />

The distinction between a blocking operation and an ordinary opeartion that merely takes a long time to finish is that a blocked thread must wait for an event that is beyond its control before it can proceed - the I/O completes, the lock becomes available, or the external computation finishes. When that external event occurs, the thread is placed back in the RUNNABLE state and becomes eligible again fro scheduling.<br />

When a method can throw InterruptedException, it is telling you that it is a blocking method, and further that if it is interrupted, it will make an effort to stop blocking early. Thread provides the interrupt method for interrupting a thread and for querying whether a thread has been interrupted. Each thread has a boolean property that represents its interrupted status; interrupting a thread sets this status.<br />

Interruption is a cooperative mechanism. One thread cannot force another to stop what it is doing and do something else; when thread A interrupts thread B, A is merely requesting that B stop what it is doing when it gets to a convenient stopping point - if it feels like it.<br />

When your code calls a method that throws InterruptedException, then your method is a blocking method too, and must have a plan for responding to interruption. For library code, there are basically two choices:

- Propagate the InterruptedException. just propagate the InterruptedException or catching it and throwing it again after performing some brief activity-specific cleanup.
- Restore the interrupt. catch InterruptedException and restore the interrupted status by calling interrupt on the current thread.

线程状态转换：
![](https://github.com/CyC2018/CS-Notes/blob/master/pics/ace830df-9919-48ca-91b5-60b193f593d2.png)


> Synchronizers: A synchronizer is any object that coordinates the control flow of threads based on its state; like blocking queues, semaphores, barriers, latches.

All synchronizers share certain structual properties: they encapsulate state that determines whether threads arriving at the synchronizer should be allowed to pass or forced to wait, provide methods to manipulate that state, and provide methods to wait efficiently for the synchronizer to enter the desired state.<br />

> Latches: A latch is a synchronizer that can delay the progress of threads until it reaches its terminal state. A latch acts as gate: until the latch reaches the terminal state the gate is closed and no thread can pass, and in the terminal state the gate opens, allowing all thread to pass. Once the latch reaches the terminal state, it cannot change state again, so it remains open forever.

Latches can be used to ensure that certain activities do not proceed until other one-time activities complete, such as:

- Ensuring that a computation does not proceed until resoures it needs have been initialized.
- Ensuring that a service does not start until other services on which it depends have started.
- Waiting until all the parties involved in an activity.

CountDownLatch: is a flexible latch implementation that can be used in any of these situations; it allows one or more threads to wait for a set of events to occur.

```java
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {}
                }
            }
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

> FutureTask: acts like a latch. (FutureTask implements Future, which descibes an abstract result-bearing computation.) A computation represented by a FutureTask is implemented with a Callable, the result-bearing equivalent of Runnable, and can be in one of three states: waiting to run, running or completed. Completion subsumes all the ways a computation can complete, including normal completion, cancellation, and exception. Once a FutureTask enters the completed state, it stays in the state forever.

The behavior of Future.get depends on the state of the task. If it is completed, get returns the result immediately, and otherwise blocks until the task transitions to the completed state and then returns the result or throws an exception. FutureTask conveys the result from the thread executing the computation to the thread retrieving the result; the specification of FutureTask guarantees that this transfer constitutes a safe publication of the result.

``` java
public class Preloader {
    private final FutureTask<ProductInfo> future = new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
          public ProductInfo call() throws DataLoadException {
            return loadProductInfo();
          }
    });

    private final Thread thread = new Thread(future);

    pubilc void start() {
        // it is inadvisable to start a thread from a constructor or static initializer 
        thread.start(); 
    }

    public ProductInfo get() 
        throws DataLoadException, InterruptedException {
            try {
                // whatever the task code may throw, it is wrapped in an ExecutionException and rethrown from Future.get
                return future.get();
            } catch (ExecutionException e) {
                Throable cause = e.getCause();
                if (cause instanceof DataLoadException) {
                    throw (DataLoadException) cause;
                } else {
                    throw launderThrowable(cause);
                }
            }
    }
}
```

Treiber stack : FutureTask中使用到了这种无锁并发栈,用来保存等待的线程，其实现方式是 CAS + 重试 <br />
[FutureTask源码解读](http://www.cnblogs.com/micrari/p/7374513.html)

> Semaphores: Counting semaphores are used to control the number of activities that can access a certain resource or perform a given action at the same time.Counting semaphores can be used to implement resource pools or to impose a bound on a collection.

A Semaphore manages a set of virtual permits; the initial number of permits is passed to the Semaphore consturctor. Activities can acquire permit (as long as some remain) and release permits when they are done with them. If no permit is available, acquire blocks until one is (or until interrupted or the operation times out). The release method returns a permit to the Semaphore.

```java
public class BoundedHashSet<T> {
    private final Set<T> set;
    private final Semaphore sem; 

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false; 
        try {
            wasAdded = set.add(o);
            return wasAdded;
        } finally {
            if (!wasAdded) {
                sem.release();
            }
        }
    }

    public boolean remove(Object o) {
        boolena wasRemoved = set.remove(o);
        if (wasRemoved) {
            sem.release();
        }
        return wasRemoved;
    }
} 
```

> Barriers: Latches are single-use objects; once a latch enters the terminal state, it cannot be reset. Barriers are similar to latches in that they block a group of threads until som event has occurred. The key difference is that with a barrier, all the threads must come together at a barrier point at the same time in order to proceed. Latches are for waiting for events; barriers are for waiting for other threads.

CyclicBarrier allows a fixed number of parties to rendezvous repeatedly at a barrier point and is useful in parallel iterative algorithms that break down a problem into a fixed number of independent subproblems. Thread call await when theye reach the barrier point, and await blocks until all the threads have reached the barrier point. If alll threads meet at the barrier point, the barrier has been successfully passed, in which case all threads are released and the barrier is reset so it can be used again. If a call to await times out or a thread blocked in await is interrupted, then the barrier is considered broken and all outstanding calls to await terminate with BrokenBarrierException.

 ```java
  public CyclicBarrier(int parties);

  /**
   * execute the given barrier action when the barrier is tripped,
   * performed by the last thread entering the barrier.
   */
  public CyclicBarrier(int parties, Runnable barrierAction);
  /**
   * Waits until all parties have invoked await on this barrier.
   * @return the arrival index of the current thread, where index
   *         {@code getParties() - 1} indicates the first
   *         to arrive and zero indicates the last to arrive
   */
  public int await() throws InterruptedException, BrokenBarrierException；
 ```

 ``` java
 public class CellularAutomata {
    private final Board mainBoard;
    private final CyclicBarrier barrier; 
    private final Worker[] workers;  

    public CellularAutomata(Board board) {
        this.mainBoard = board;
        int count = Runtime.getRuntime().availableProcessors();
        this.barrier = new CyclicBarrier(count, new Runnable() {
            public void run() {
                mainBoard.commitNewValues();
            }
        });
        this.worker = new Worker[count];
        for (int i = 0; i < count; i++) {
            worker[i] = new Worker(mainBoard.getSubBoard(count, i));
        }
    }

    private class Worker implements Runnable {
    private final Board board;

    public Worker(Board board) {
        this.board = board;
    }

    public void run() {
        while (!board.hasConverged()) {
            for (int x = 0; i < boardMaxX(); x++) {
                for (int y = 0; y < board.getMaxY(); y++) {
                    board.setNewValue(x, y, computeValue(x, y));
                }
            }
            try {
                barrier.await();
            } catch (InterruptedException ex) {
                return;
            } catch (BrokenBarrierException ex) {
                return;
            }
        }
    }
 }

 public void start() {
    for (int i = 0; i < workers.length; i++) {
        new Thread(workers[i]).start();
    }
    mainBoard.waitForConvergence();
 } 
}
 ```

Another form of barrier is Exchanger, a two-party barrier in which the parties exchange data at the barrier point.<br />

[Exchanger](!https://www.cnblogs.com/12344321hh/p/10637358.html)

```java
//实现一个缓存器
public interface Computable<A, V> {
	V compute(A args) throws InterruptedException;
}

public class Memoizer<A,V> implements Computable<A,V>{
	private final ConcurrentHashMap<A,FutureTask<V>> cache = 
			new ConcurrentHashMap<>();
	
	private final Computable<A,V> comp;
	
	public Memoizer(Computable<A,V> comp) {
		this.comp = comp;
	}
	
	public V compute(A args) throws InterruptedException {
		
		while(true) {
			FutureTask<V> f = cache.get(args);
			
			if(f == null) {
				Callable<V> callable = new Callable<V>() {
					@Override
					public V call() throws InterruptedException {
						return comp.compute(args);
					}
				};
				
				FutureTask<V> ft = new FutureTask<>(callable);
				
				f = cache.putIfAbsent(args, ft);
				
				if(f == null) {
					f = ft;
					ft.run();
				}
			}
			
			try {
				return f.get();
			} catch(CancellationException e) {
				cache.remove(args, f);  // Cache Pollution, removed
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
	}
}
```

-------
> 无限制地创建线程的问题：
 - 线程生命周期的开销非常高；
 - 资源消耗；如果可运行的线程数量多于可用的处理器数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他性能开销。如果已经有足够多的线程使所有CPU保持忙碌状态，那么再创建更多线程反而会降低性能。
 - 稳定性；在可创建线程的数量上存在一个限制，如果破坏这些限制，可能会抛出OutOfMemoryError。

> Executor框架：任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。在Java类库中，任务执行主要抽象不是Thread，而是Executor。**Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。任务的提交和执行解耦。**
```java
public interface Executor {
    void execute(Runnable command);
}
```

> 线程池：通过调用Executors中的静态方法创建线程池

- newFixedThreadPool
- newCachedThreadPool
- newSingleThreadExecutor
- newScheduledThreadPool

> Executor生命周期： 
 
为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口,Executor生命周期有3中状态：运行、关闭、已终止。
```java
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    Future<?> submit(Runnable task);
    <T> Future<T> submit(Runnable task, T result);
    <T> Future<T> submit(Callable<T> task);
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
}
```

------
> Runnable 、 Callable
```java
public interface Runnable {
// 不能返回值，不能抛出异常
    public abstract void run();  
}

public interface Callable<V> {
    V call() throws Exception;
}

```


```java

public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);
	boolean isCancelled();
	boolean isDone();
	V get() throws InterruptedException, ExecutionException;
	V get(long timeout, TimeUnit unit)
       	 throws InterruptedException, ExecutionException, TimeoutException;
}

```

> CompletionService : 将 Executor 和 BlockingQueue 功能融合。ExecutorCompletionService 是其实现类。

------
> 任务取消：java中没有一种安全的抢占式方法来停止线程，因此也没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。

**通常，中断是实现取消的最合理方式。**

> Thread中的中断方法：
 
```java
    public void interrupt(); // 中断目标线程
    public boolean isInterrupted(); // 返回目标线程的中断状态
    public static boolean interrupted(); // 清除当前线程的中断状态，并返回清除之前的值
    
```
中断操作并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。

> JVM 关闭：JVM 既可以正常关闭，也可以强行关闭。

正常关闭的触发方式包括：
- 最后一个"正常(非守护)"线程结束
- 调用System.exit()
- 通过其他特定于平台的方法关闭(如发送SIGINT信号或键入 Ctrl-C)

强行关闭：调用 Runtime,halt 或者在操作系统中"kill" JVM 进程(如发送SIGKILL)。

> 关闭钩子: 

```java
Runtime.getRuntime().addShutdownHook(Thread hook);
```

> 守护线程(Daemon Thread)：线程分为两种：普通线程和守护线程。在 JVM 启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程(如垃圾回收器以及其他执行辅助工作的线程)。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。

普通线程和守护线程的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM 会正常退出。当JVM 停止时，所有仍然存在的守护线程都将被抛弃(既不会执行finally代码块，也不会执行回卷栈，JVM只是直接退出)。

> finalize() ： **避免使用**

------

## 线程池： 
> 线程饥饿死锁(Thread Starvation Deadlock)：线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，除非线程池足够大，否则将发生线程饥饿死锁。

> 获取CPU数目：

```java
Runtime.getRuntime().availableProcessors();
```

> ThreadPoolExecutor:
 Executors中 newCachedThreadPool 和 newFixedThreadPool 返回的线程池都是 ThreadPoolExecutor 类型。
 
 **只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列可能导致线程"饥饿"死锁问题。此时，应该使用无界的线程池，如 Executors.newCachedThreadPool()。**
 
> 饱和策略：当有界队列被填满后，饱和策略开始发挥作用(如果某个任务被提交到一个已被关闭的Executor,也会用到饱和策略)。

JDk提供的饱和策略(均实现了 RejectedExecutionHandler 接口)：
- AbortPolicy ： 默认策略，抛出 RejectedExecutionException
- CallerRunsPolicy ：Executes task in the caller's thread, unless the executor has been shut down, in which case the task is discarded.
- DiscardPolicy ：新提交的任务无法保存到队列中等待执行时，悄悄抛弃该任务，do nothing
- DiscardOldestPolicy ： 抛弃下一个将被执行的任务，然后尝试重新提交新任务

```java
//ThreadPoolExecutor通过调用该方法修改饱和策略
public void setRejectedExecutionHandler(RejectedExecutionHandler handler);

// RejectedExecutionHandler 接口定义
public interface RejectedExecutionHandler {
	void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

> 线程工厂：线程池需要创建一个新线程时，调用ThreadFactory.newThread();默认的线程工厂方法创建一个新的、非守护的线程，并且不包含特殊的配置信息。

```java 
public interface ThreadFactory {
	Thread newThread(Runnable r);
}
```
