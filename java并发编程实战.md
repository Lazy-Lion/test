
> java同步机制：
 - synchronized关键字： 提供一种独占的加锁方式
 - volatile 
 - 显示锁 (Explicit Lock)
 - 原子变量

> 如果多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。可以有三种方式修复这个问题：
  - 不在线程间共享该状态变量；
  - 将状态变量修改为不可变的变量；
  - 在访问状态变量时使用同步；
  
> 编写并发代码的原则：

 首先使代码正确运行，然后再提高代码的速度。即使如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能的提升时，才进行优化。
 
> 竞态条件(Race Condition)：多个线程由于不恰当的执行时序而出现不正确的结果

大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算。
( **数据竞争：如果在访问共享的非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争。**)

> 通常在简单性和性能之间存在相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性(这可能会破坏安全性)。

> 当执行时间较长的计算或者可能无法快速完成的操作时(例如，网络I/O或控制台I/O),一定不要持有锁。

> 重排序：只要在某个线程中无法检测到重排序的情况(即使在其他线程中可以明显地看到该线程中的重排序)，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

> java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型 的double和long变量，JVM允许将64位的读操作和写操作分解成两个32位的操作。当读取一个非volatile类型的long变量时，如果该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作都必须在同一个锁上同步。

> volatile 变量: 在访问volatile变量时不会执行加锁操作，因此也就不会执行线程阻塞，所以volatile变量是比synchronized关键字更轻量级的同步机制；volatile变量会限制一些重排序操作，volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

volatile变量的正确使用方式： 确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生(例如，初始化或关闭)。
<br />
加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
<br />
当且仅当满足以下条件时，才应该使用volatile变量：
 - 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值；
 - 该变量不会与其他状态变量一起纳入不变性条件中；
 - 在访问变量时不需要加锁；

> 发布(publish)与逸出(escape)： 发布一个对象是指使对象能在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况被称为逸出。
``` java
	public static Set<Secret> knownSecrets;
	
	public void initialize() {
		knownSecrets = new HashSet<Secret>();
	}
```
> 线程封闭： 当访问共享的可变数据时，通常需要同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。

- Ad-hoc 线程封闭： 维护线程封闭性的职责完全由程序实现来承担。(脆弱，少用)
- 栈封闭：只能通过局部变量才能访问对象。java语言的语义确保了基本类型的局部变量始终封闭在线程内；在维持对象引用的栈封闭性时需要额外工作确保被引用的对象不会逸出。
- ThreadLocal类：ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用该技术。(实现上ThreadLocal中存储值的对象ThreadLocalMap保存在相应线程的Thread对象中，当线程终止后，这些值会作为垃圾回收)。
``` java
 private static ThreadLocal<Connection> connectionHolder =
   new ThreadLocal<Connection>(){
       public Connection initialValue(){ // 某个线程初次调用ThreadLocal.get(),就会调用获取初始值
           return DriverManager.getConnection(DB_URL);
       }
   };
```
> 不变性： 不可变对象(immutable object)一定是线程安全的。

当满足以下条件时，对象才是不可变的：
 - 对象创建以后其状态就不能修改；
 - 对象的所有域都是final类型(从技术上来看，不可变对象并不需要将其所有的域都声明为final类型，如String的hash域)；
 - 对象是正确创建的(在对象的创建时期，this 没有逸出)；
 ```java
     public int hashCode() { // hash的计算推迟到第一次调用hashCode(),基于final域value,每次计算结果都相同
        int h = hash; 
        if (h == 0 && value.length > 0) {
            char val[] = value;
            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
 ```

> final 域：final类型的域是不能修改的(但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的)。在java内存模型中，final域有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。

**"除非需要更高的可见性，否则应将所有的域都声明为私有域"是一个良好的编程习惯；"除非需要某个域是可变的,否则应将其声明为final域"也是一个良好的编程习惯。**

> 在并发程序中使用和共享对象时，实用的一些策略：
 - 线程封闭： 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由该线程修改；
 - 只读共享： 在没有额外的同步情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象(Effectively Immutable Object, 对象从技术上来看是可变的，但其状态在发布后不会再改变)。
 - 线程安全共享： 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步；
 - 保护对象： 被保护的对象只能通过持有特定的锁访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

------
> 同步容器类：Vector 、Hashtable 、 Collections.synchronizedXxx() ， 实现线程安全的方式是将状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。

同步容器类都是线程安全的，但是在某些情况下可能需要额外的客户端加锁来保护符合操作。常见的符合操作：
- 迭代
- 跳转(根据指定顺序找到当前元素的下一个元素)
- 条件运算

在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。

> 迭代器(Iterator) 和 ConcurrentModificationException: 当发现容器在迭代过程中被修改，就会抛出一个ConcurrentModificationException (fail-fast机制)；实现上是将计数器的变化和容器关联，如果迭代期间计数器被修改，则抛出异常。(**在单线程代码中也可能抛出ConcurrentModificationException异常，当对象直接从容器中删除而不是通过Iterator.remove()来删除时就会抛出该异常。<remove()方法会修改exceptedModCount的值>**)

迭代过程中避免出现ConcurrentModificationException:
- 对容器加锁
- 克隆容器，在副本上进行迭代

容器的某些方法会间接地执行迭代操作，如hashCode(),equals()等，这些同样可能会抛出ConcurrentModificationException;

> 并发容器： ConcurrentHashMap (替代同步且基于散列的Map), ConcurrentSkipListMap (替代同步的SortedMap), ConcurrentSkipListSet (替代同步的SortedSet), CopyOnWriteArrayList (在遍历操作为主要操作的情况下代替同步的List), ConcurrentLinkedQueue (FIFO队列),BlockingQueue (阻塞队列，"生产-消费者"模式)<PriorityQueue，优先队列，不是并发的>

- ConcurrentHashMap : jdk 7 : 分段锁实现，对整个Map进行计算的方法语义进行弱化，如size返回的结果可能已经过期，实际上只是个估计值； <br />jdk 8 : CAS，synchronized实现
 
 并发容器提供的迭代器不会抛出 ConcurrentModificationException ,因此不需要在迭代过程中对容器加锁。ConcurrentHashMap 返回的迭代器具有弱一致性 (Weaklly Consistent)，而并非"fail-fast"。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以(但不保证)在迭代器被构造后将修改操作反映给容器。




