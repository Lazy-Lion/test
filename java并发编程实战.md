#### Word List: 
 - civil engineering 土木工程
 - rivet 铆钉
 - I-beam 工字梁
 - fall down 失败；倒塌
 - means to an end 达到目的的手段
 - externally 外部地；外表上
 - coordinate v.调节； n.坐标； adj.坐标的
 - corruption 贪污；腐败；堕落
 - mechanism 机制；原理
 - temptation 引诱；诱惑物
 - omit 省；，疏忽
 - trival 不重要的；琐碎的
 - retrofit 改进；更新
 - maintainable 可维护的
 - encapsulation 封装
 - invariant n.不变量；adj.不变的
 - at odds with 与..争执；意见不一致
 - compromise 妥协
 - sake 目的；利益；理由
 - compatibility 兼容性
 - legacy 遗产；遗留问题
 - not nearly 远非
 - pursue 继续；追赶；纠缠
 - realistic 现实的
 - adhere 坚持；依附；追随
 - dwarf adj.矮小的；v.变矮；n.矮子，侏儒
 - fragile 脆的，易碎的
 - characterize 描绘..特性；塑造人物
 - interchangeably 可交换地
 - thus far 迄今，现在为止
 - composition 作文；作曲；作品；构成；合成物；成分
 - make sense 有意义
 - make sense of 搞清..的意思
 - make sense to 对..合乎情理；有意义
 - make sense for 对..有意义
 - make sense out of 弄明白；理解
 - tricky 狡猾的；机警的；棘手的
 - intuitive 直觉的
 - counterintuitive 违反直觉的
 - downright 向下；完全地；(坏事)彻头彻尾的；(人的举止或行为)直率的；径直前进的
 - numerous 许多的
 - turn up 出现
 - no wonder 难怪
 - interaction 交互
 - suspiciously 怀疑地；猜测地
 - fuzzy 模糊的；失真的
 - conform 符合
 - constrain 约束
 - adequate 充足的；适当的；胜任的
 - convince 确信
 - interleave 交错；交叉
 - regardless of 不管；不顾
 - violate 违反；妨碍；侵犯
 - post-conditions 后置条件
 - stem from 起源于
 - facility 设施；设备；才能；天赋
 - factorization 因式分解
 - preserve 保留；保存
 - transient 短暂的
 - solely 单独地；仅仅
 - burden 负担
 - susceptible 易受影响的；敏感的
 - compact 袖珍的；紧凑的
 - indivisible 不可分割的
 - shorthand 速记
 - discrete 离散的；不连续的
 - derive from 源于
 - simultaneously 同时地
 - permanently 永久地
 - integrity 完整；正直；诚实
 - presence 存在；出席
 - arise 出现；发生
 - stand up 坚持；拥护；站得住脚
 - frustrated 沮丧的
 - nip 夹；捏；剪断；冻伤；阻止
 - idiom 习语
 - defer 推迟
 - undermine 破坏
 - vagary n.变换莫测
 - compound n.化合物，混合物；adj.混合的；v.合成，混合，恶化，和解，妥协
 - with respect to 相对于
 - prespective n.视角，远景，透视图；adj.透视的
 - either or 两者择一的
 - neither nor 既不是..也不是
 - refer 涉及；参考；查阅
 - collectively 集体地；共同地
 - necessarily 必要地；必然地；必定地
 - arbitrary 任意的；武断的；专制的
 - reason about 推出
 - consecutive 连续的
 - vulnerability 易损性；弱点
 - span v.跨越;n.跨度
 - guard 保卫；看守
 - mutual 共同的
 - intrinsic 本质的；固有的
 - fairly 相当地；公平地
 - extreme adj.极端的；n.极端
 - inhibit 阻止
 - be addressed 得到解决
 - basis 基础
 - acquisition 获得
 - stall n.货摊，畜栏，（房间内的）小隔间，车位，（车辆）熄火，（飞机）失速；v.熄火，拖延，暂缓
 - inherent 固有的；内在的；与生俱来的
 - convention 大会；惯例；约定；协定；习俗
 - throughout 自始至终；遍及
 - retrospect 回顾
 - tradeoff 权衡；折衷；（公平）交易
 - subvert 颠覆；推翻；破坏
 - audit 审计
 - ripple 波纹；涟漪
 - periodic 周期的；定期的
 - cure v.治疗，解决（问题）；n.药物，治疗
 - indiscriminate 任意的；无差别的
 - merely 仅仅，只不过
 - render v.致使，提供，提出，渲染
 - coarse-grained 粗鲁的；木纹粗糙的；粗略的；大概的
 - intend 打算
 - idle 闲置的
 - bonus 奖金；红利
 - constitute 构成；任命
 - portion n.部分；v.将..分配
 - revert 重新提到；回复
 - overhead n.经常性支出；adv.在头顶上方，在空中；adj.（费用开支等）日常的，在空中的
 - unduly 过度地；不适当地
 - tension n.张力，拉力，紧张，电压；v.使紧张，使拉紧
 - resist v.抵抗，忍耐；n.抗蚀剂
 - prematurely 过早地
 - sacrifice 牺牲
 - misconception 误解
 - demarcate 划分界线；区别
 - subtle 微妙的；精细的
 - intervene v.介于；adj.介于中间的
 - phenomenon 现象；奇迹；杰出人才
 - apparent 显然的；表面上的
 - in the absence of 缺少..时
 - weird 怪异的；不可思议的
 - insufficiently 不足地；不能胜任地
 - prohibitively 禁止地；过分地
 - scary 可怕的
 - stale 陈旧的
 - all or nothing 孤注一掷的；全部或一无所有的
 - edible adj.可食用的；n.食品
 - prevent 阻止；妨碍
 - analogous 类似的
 - hazard n.危害；v.使冒危险
 - out of thin air 无中生有地
 - prior 优先的
 - alternative 供选择的
 - propagate 传播；宣传；繁殖
 - roughly 大致；粗略地
 - anthropomorphized  给..赋予人性
 - cumbersome 笨重的
 - hoist v.升高，举起；n. 提升，起重
 - blatant 喧嚣的；公然的；炫耀的；显眼的
 - indirectly 间接地
 - abbreviation 缩写
 - misuse 误用
 - maliciously 有敌意地；恶意地
 - carelessly 粗心地
 - compelling 引人注目的；令人信服的；不可抗拒的
 - compel v.强迫
 - steal 偷窃
 - mischief 恶作剧；伤害
 - confinement 限制
 - swing n.摇摆，秋千；adj.旋转的，悬挂的，强节奏爵士音乐的；v.摇摆，转向，悬挂
 - extensively 广阔地；广泛地
 - dispatch 派遣；发送
 - other than 除了
 - dispense 分发；免除
 - enforce 实施；执行；强制
 - responsibility 责任；义务
 - responsiveness n.响应能力，有同情心
 - even with 即使有
 - outweight 比..重要
 - sparingly 节俭地；保守地；爱惜地
 - primitively 最初地；原始地
 - associate v.联系，关联；n.伙伴，联想；adj.联合的，副的
 - straightforward 简单的；直截了当地
 - mundane 平凡的；世俗的；宇宙的；世界的
 - consult 请教；咨询
 - conceptually 概念上
 - port n.港口，口岸，端口，舱门，左舷；v.持（枪），左转舵
 - abuse 滥用
 - property 性质；性能；财产；所有权
 - detract 贬低；减去；转移；使分心
 - reusability 可重用性
 - couple n.对，夫妇；v.结合，连接，成婚
 - buggy 多虫的
 - delicate 微妙的；精美的；可口的
 - benign 良性的；和蔼的；吉利的
 - unwarranted 无根据的；无保证的
 - eliminate 消除，排除
 - interfere 干涉；妨碍；冲突；介入
 - harmless 无害的；无恶意的
 - immune adj.免疫的，免于..的；n.免疫者
 - entail 需要
 - for the moment 暂时；暂且；目前
 - fulfill 满足
 - engagement 婚约；约会；诺言；参与度
 - compose 组成；构成；作曲；写作
 - comprise 包含，由..组成
 - encompass 包含；环绕
 - take on 承担
 - derive 源于；导出
 - impose 强加；利用
 - transition 过渡；转变
 - underlying 潜在的；根本的
 - obey 服从
 - precondition 先决条件
 - tightly 紧紧地
 - implied 暗指的；隐式的 
 - embody 体现；具体表达
 - ownership 所有权
 - short-term 短期的
 - long-term 长期的
 - loan n.贷款；v.借
 - envision 想象；预想
 - joint adj.联合的，合办的，共同拥有的；n.关节，接合处，（非正式）娱乐场所；v.连接
 - precise 精确的；严格的
 - exhibit n.展览品，展览会，证据；v.展览，提出（证据等）
 - infrastructure 基础设施；公共建设
 - safekeep 保护
 - passivation 钝化处理
 - discipline n.学科，纪律，训练，惩罚；v.训练，惩戒
 - so long as 只要
 - inspire 激发；鼓舞
 - sophisticated 复杂的；久经世故的
 - scalability 扩展性
 - widget 装饰品；小部件
 - fleet adj.快速的，敏捷的，（水）浅的；n.船队，舰队，海军，车队，小河，水道，沟；v.（诗歌或文学）飞逝，疾驰，使（时间）飞快地过去，消失，转瞬即逝 
 - concise 简明的
 - taxicab 出租车
 - manually 手动地
 - drawback 缺点，不利条件，退税
 - degrade 降低
 - scratch n.擦伤，抓痕；v.抓，刮，乱涂；adj.打草稿用的，凑合的
 - substantial adj.大量的，实质的；n.本质，重要材料
 - liability 责任；债务；倾向；可能性；不利因素
 - shallow n.浅滩；adj.浅的，肤浅的；v.变浅
 - accommodate 容纳；适应；调解
 - at once 立刻；马上

Writing thread-safe code is about managing access to **shared, mutable** state.


> java synchronization：

 - synchronized keywords： provide exclusive locking 
 - volatile variables
 - Explicit Lock
 - atomic variables

> if multiple threads access the same mutable state variable without appropriate synchronization, your program is broken. There are three ways to fix it: 

  - Don't share the state variable across thread;
  - Make the state variable immutable
  - Use synchronization whenever accessing the state variable
  

> Practice:

  It is always a good practice first to make your code right, and then make it fast. Even then, pursue optimization only if you performance measurements and requirements tell you that you must, and if those some measurements tell you that your optimization actually made a difference under realistic conditions.

a program that consists entirely of thread-safe class may not be thread-safe, and a thread-safe classes may contain classes that are not thread-safe.


> Thread-safe class:

 A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordinationon the part of the calling code. <br />

 No set of operations performed sequentially or concurrently on instances of a thread-safe class can cause an instance to be in an invalid state. <br />

 Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.

 Stateless objects are always thread-safe.

> Race Conditions

  A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime; in other words, when gettig the right answer relieson lucky timing. <br />

  The most common type of race condition is check-then-act, where a potentially stale observation is used to make a descision on what to do next.<br />

  To ensure thread safety, check-then-act operations (like lazy initialization) and read-modify-write operations (like increment) must always be atomic.

( **data race: arises when synchronization is not used to coordinate all access to a shared non-final field. Not all race conditions are data races, and not all data races are race conditions, but they both can cause concurrent programs to fail in unpredictable ways.** )

> synchronized:

``` java
  synchronized (lock) {
    // body 
  }
```
synchronized block has two parts:

 - a reference to an object that will serve as the lock (Synchronized method's lock is the object on which the mehtod is being invoked. Static synchronized methods use the Class object for the lock.)
 - a block of code to be guarded by that lock (synchronized method spans an entire method body)

> Intrinsic locks 

  Every Java object can implicitly act as a lock for purposes of synchronization; these built-in locks are called intrinsic locks or monitor locks. The lock is automatically acquired by the executing thread before entering a synchronized block and automatically released when control exits the synchronized block, whether by the normal control path or by throwing an exception out of the block.The only way to acquire an intrinsic lock is to enter a synchronized blcok or method guarded by that lock. <br />

  Intrinsic locks in Java act as mutexes (or mutual exclusion locks), which means that at most one thread may own the lock.<br />

  Intrinsic locks are reentrant, if a thread tries to acqire a lock that it already holds, the request succeeds.

> Serialized access:

  Serialized acess to an object has nothing to do with object serialization; serialized access means that threads take turns accessing the object exclusively, rather than doing so concurrently.

Every shared, mutable variable should be guarded by exactly **one lock**.

There is frequently a tension between simplicity and performance.When implementing a synchronization policy, resist the temptation to prematurely sacrifice simplicity (potentially compromising safety) for the sake of performance.

Avoid holding locks during lengthy computations or operations at risk of not completing quickly such as network or console IO.

> Memory Visibility 

In order to ensure visibility of memory writes across threads, you must use synchronization.

> Reordering

There is no guarantee that operations in one thread will be performed in the order given by the program, as long as the reordering is not detectable from within that thread - even if the reordering is apparent to other threads.

> The Java Memory Model requires fetch and store operations to be atomic, bur for nonvolatile long and double variables, the JVM is permitted to treat a 64-bit read or write as two separate 32-bit operations.If the reads and writes occur in different threads, it is therefore possible to read a nonvolatile long and get back the high 32 bits of one value and the low 32 bits of another.

> Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all thread see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lcok.

> Volatile Variables 

When a field is declared volatile, the compiler and runtime are put on notice that this variable is shared and that operations on it should not be reordered with other memory operations.Volatile variables are not cached in registers or in caches where they are hidden from other processors, so a read of a volatile variable always returns the most recent write by any thread.<br />

Yet accessing a volatile variable perfroms no locing and so cannot cause the executing thread to block, making volatile variables a lighter-weight synchronization mechanism than synchronized. (Volatile reads are only slightly more expensive than nonvolatile reads on most current processor architectures.) <br />

Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when verifying correctness would require subtle reasoning about visibility. Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event(such as initialization or shutdown) has occurred. <br />

Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.<br />

You can use volatile variables only when all the following criteria are met:

- Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;
- The variable does not participate in invariants with other state variables;
- Locing is not required for any other reason while the variable is being accessed.

> Publication and Escape

Publishing an object means making it available to code outside of its current scope, such as by storing a reference to it where other code can find it, returning it from a non-private method, or passing it to a method in another class.<br />

An object that is published when it should not have been is said to have escaped.<br />

An object is in a predictable, consistent state only after its constructor returns, so publishing an object from within its constructor can publish an imcompletely constructed object. This is true even if the publication is the last statement in the constructor. If the this reference escapes during construction, the object is considered not properly constructed.<br />

When an object create a therad from its constructor, it almost always shares its this reference with the new thread, either explicitly (by passing it to the constructor) or implicitly (because the Thread or Runnable is an inner class of the owing object). The new Thread might then be able to see the owning object before it is fully constructed. There is noting wrong with creating a thread in a consturctor, but it is best not to start the thread immediately. Instead, expose a start or initialize method that starts the owned thread.Calling an overrideable instance method (one that is neither private nor final) from the constructor can also allow the this reference to escape.

> Thread Confinement

If data is only accessed from a single thread, no synchronization is needed.When an object is confined to a thread, such usage is automatically thread-safe even if the confined object itself is not.This technique, thread confinement, is one of the simplest ways to achieve thread safety.<br />

- Ad-hoc Thread Confinement: Ad-hoc thread confinement describes when the responsibility for maintaining thread confinement falls entirely on the implementation.Ad-hoc thread confinement can be fragile because none of the language features, it should be used sparingly.
- Stack Confinement: An object can only be reached through local variables.Maintaining stack confinement for object references requires a little more assistance from the programmer to ensure that the referent does not escape.
- ThreadLocal: Allows you to associate a per-thread value with a value-holding object. The thread-specific values are stored in the Thread object itself, when the thread terminates, the thread-specific values can be garbage collected.

``` java
 private static ThreadLocal<Connection> connectionHolder =
   new ThreadLocal<Connection>(){
       public Connection initialValue(){ 
       // when a thread calls ThreadLocal.get for the first time, initialValue is consulted to provide the initial value for that thread.
           return DriverManager.getConnection(DB_URL);
       }
   };

 public static Connection getConnection() {
    return connectionHolder.get();
 }
```

> Immutability 

An immutable object is one whose state cannot be changed after construction. Immutable objects are inherently thread-safe; their invariants are established by the consturctor, and if their state cannot be changed, these invariants always hold.

An object is immutable if: 

- Its state cannot be modified after construction
- All its field are final (It is technically possible to have an immutable object without all fields being final. java.lang.String lazily computes the hash code the first time hashCode is called and caches it in a non-fianl field, but this work only because that field can take on only one non-default value that is the same every time it is computed because it is derived deterministically from immutable state.)
- It is properly constructed (the this reference does not escape during construction)

 ```java
 public int hashCode() { 
 // hash的计算推迟到第一次调用hashCode(),基于final域value,每次计算结果都相同
   int h = hash; 
   if (h == 0 && value.length > 0) {
     char val[] = value;
     for (int i = 0; i < value.length; i++) {
       h = 31 * h + val[i];
     }
     hash = h;
   }
   return h;
 }
 ```

> Final Fields

Final fields cannot be modified (although the objects they refer to can be modified if they are mutable), but they also have special semantics under the Java Memory Model. It is the use of final fields that makes possible the guarantee of initialization safety that lets immutable objects be freely accesssed and shared without synchronization.<br />

Just as it is a good practice to make all fields private unless they need greater visibility, it is a good practice to make all fields final unless they need to be mutable.

> safe publication

``` java
// unsafe publication
public Holder holder;

pubic void initialize() {
    holder = new Holder(42);
}
```

Two things can go wrong with improperly published objects.Other threads could see a stale value for the Holder field, and thus see a null reference or other older value even though a value has been placed in Holder (While it may seem that field values set in a constructor are the first values written to those fileds and therefore that there no "older" values to see stale value, the Object constructor first writes the default values to all fields before subclass construcotrs run. It is therefore possible to see the default value for a field stale value.).

> Immutable Objects and Initialization Safety

Because immutable objects are so important, the java Memory Model offers a special guarantee of initialization safety for sharing immutable object. An object reference becomes visible to another thread does not necessarily mean that the state of that object is visible to the consuming thread. In order to guarantee a consistent view of the object's state, synchronization is needed.<br />

Immutable objects can be safely accessed even when synchronization is not used to publish the object reference. For this guarantee of initialization safety to hold, all of the requirements for immutability must be met: unmodifiable state, all fields are final, and proper construction. <br />

Immutable objects can be used safely by any thread without additional synchronization, even when synchronization is not used to publish them.<br />

This guarantee extends to the values of all final fields of properly constructed objects; final fields can be safely accessed without additional synchronization. However, if final fields refer to mutable objects, synchronization is still required to access the state of the objects they refer to.

> Safe Publication Idioms

To publish an object safely, both the reference to the object and the object's state must be made visible to other threads at the same time. A properly constructed object can be safely published by:

- Initializing an object reference from static initializer;
- Storing a reference to it into a volatile field or AtomicReference;
- Storing a reference to it into a final field of a properly constructed object
- Storing a reference to it into a field that is properly guarded by a lock

> Effectively Immutable Objects

Objects that are not technically immutable, but whose state will not modified after publication, are called effectively immutable.<br />

Safely published effectively immutable objects can be used safely by any thread without additional synchronization.

> Mutable Objects

To share mutable objects safely, they must be safely published and be either thread-safe or guarded by a lock. <br />

The publication requirements for an object depend on its mutability:

- Immutable objects can be published through any mechanism
- Effectively immutable objects must be safely published
- Mutable objects must be safely published, and must be either thread-safe or guarded by a lock.

> Sharing Objects Safely 

The most useful policies for using and sharing objects in a conucrrent program are: 

- Thread-confined. A thread-confined object is owned exclusively by and confined to one thread, and can be modified by its owning thread.
- Shared read-only. A shared read-only object can be accessed concurrently by multiple threads without additional synchronization, but cannot be modified by any thread. Shared read-only objects include immutable and effectively immutable objects.
- Shared thread-safe. A thread-safe object performs synchronization internally, so multiple threads can freely access it through its public interface without further synchronization.
- Guarded. A guarded object can be accessed only with a specific lock held. Guarded objects include those that are encapsulated within other thread-safe objects and pubished objects that are known to be guarded by a specific lock.


> Instance Confinement 

If an object is not thread-safe, several techniques can still let it be used safely in a multithreaded program. You can ensure that it is only accessed from a single thread (thread confinement), or that all access to it is properly guarded by a lock.<br />

Encapsulating data within an object confines access to the data to the object's methods, make it easier to ensure that the data is always accessed with the appropriate lock held.<br />

Confined objects must not escape their intended scope. An object may be confined to a class instance (such as a private class member), a lexical scope (such as a local variable), or a thread (such as an object that is passed from method to method within a thread, but not supposed to be shared across threads.)

> The Java Monitor Pattern

```java
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;

    void someMethod() {
        synchronized (myLock) {
            // access or modify the state of widget
        }
    }
}
```

Making the lock object private encapsulates the lock so that client code cannot acquire it, whereas a publicly accessible lock allows client code to participate in its synchronization policy - correctly or incorrectly.


> 同步容器类：Vector 、Hashtable 、 Collections.synchronizedXxx() ， 实现线程安全的方式是将状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。

同步容器类都是线程安全的，但是在某些情况下可能需要额外的客户端加锁来保护符合操作。常见的符合操作：
- 迭代
- 跳转(根据指定顺序找到当前元素的下一个元素)
- 条件运算

在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。

> 迭代器(Iterator) 和 ConcurrentModificationException: 当发现容器在迭代过程中被修改，就会抛出一个ConcurrentModificationException (fail-fast机制)；实现上是将计数器的变化和容器关联，如果迭代期间计数器被修改，则抛出异常。(**在单线程代码中也可能抛出ConcurrentModificationException异常，当对象直接从容器中删除而不是通过Iterator.remove()来删除时就会抛出该异常。<remove()方法会修改exceptedModCount的值>**)

迭代过程中避免出现ConcurrentModificationException:
- 对容器加锁
- 克隆容器，在副本上进行迭代

容器的某些方法会间接地执行迭代操作，如hashCode(),equals()等，这些同样可能会抛出ConcurrentModificationException;

-------
> 并发容器： ConcurrentHashMap (替代同步且基于散列的Map), ConcurrentSkipListMap (替代同步的SortedMap), ConcurrentSkipListSet (替代同步的SortedSet), CopyOnWriteArrayList (在遍历操作为主要操作的情况下代替同步的List), ConcurrentLinkedQueue (FIFO队列),BlockingQueue (阻塞队列，"生产-消费者"模式)<PriorityQueue，优先队列，不是并发的>

- ConcurrentHashMap : jdk 7 : segment 实现，对整个Map进行计算的方法语义进行弱化，如size返回的结果可能已经过期，实际上只是个估计值；<br /> jdk 8 : CAS，synchronized 实现


 [为并发而生的 ConcurrentHashMap（Java 8）](https://www.jianshu.com/p/e99e3fcface4)
  <br />
 [为什么ConcurrentHashMap的读操作不需要加锁？](https://juejin.im/entry/5b98b89bf265da0abd35034c)
 
 并发容器提供的迭代器不会抛出 ConcurrentModificationException ,因此不需要在迭代过程中对容器加锁。ConcurrentHashMap 返回的迭代器具有**弱一致性** (Weaklly Consistent)，而并非"fail-fast"。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以(但不保证)在迭代器被构造后将修改操作反映给容器。
 <br />

- CopyOnWriteArrayList : 每次修改容器都会复制底层数组(并且使用 ReentrantLock )，所以仅当迭代操作远远多于修改操作时才应该使用。容器的迭代器保留一个指向底层数组的引用，由于底层数组不会被改变，所以对其进行同步只需确保数组内容的可见性。该容器的迭代器不会抛出 ConcurrentModificationException 。

- BlockingQueue 和 producer-consumer模式

```java
/* Inserts the specified element into this queue, waiting if necessary for space to become available. */
    void put(E e) throws InterruptedException;
    
/* Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. */    
    E take() throws InterruptedException;
```

| Implements | |
| - | - |
| ArrayBlockingQueue | FIFO，有界 |
| LinkedBlockingQueue | FIFO，有界或无界 |
| PriorityBlockingQueue | 有界，按优先级排序，自然序:Comparable 或 比较器：Comparator |
| SynchronousQueue | 同步队列，不为队列中的元素维护存储空间;它维护一组线程，这些线程在等待把元素加入或移出队列; 不是一个真正的队列，而是一种在线程之间进行移交的机制，Executors.newCachedThreadPool()使用了这种队列 |

队列可以是有界的，也可以是无界的，无界队列永远不会充满，因此无界队列上的 put 永远不会阻塞(通常这种无界不是真的无界，而是容量是Integer.MAX_VALUE)。
<br />
[解读 Java 并发队列 BlockingQueue](https://javadoop.com/2017/08/22/java-concurrent-queue/?)

**在构建高可用的应用程序时，有界队列是一种强大的资源管理工具，它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。**


> java 6 新增两个容器类型 ： Deque (发音"deck") 和 BlockingDeque, 分别对Queue和BlockingQueue进行扩展。实现类包括 ArrayDeque 和 LinkedBlockingDeque。 Deque 是一个双端队列，实现了在队列头和队列尾高效插入和移除。<br /> 双端队列适用的模式是**工作密取(Work Stealing)**:在生产者-消费者模式中，所有消费者有一个共享的工作队列，在工作密取中，每个消费者都有各自的双端队列。如果一个消费者完成自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。

------
线程状态转换：
![](https://github.com/CyC2018/CS-Notes/blob/master/pics/ace830df-9919-48ca-91b5-60b193f593d2.png)

> 阻塞方法和中断方法： 

线程阻塞(BLOCKED、WAITING、TIMED_WAITING)的一些原因： 
  - 等待I/O 操作结束
  - 等待获得锁
  - 等待从Thread.sleep方法中醒来
  - 等待另一个线程的计算结果

**阻塞操作与执行时间很长的普通操作的差别在于，被阻塞的线程必须等待某个不受它控制的事件发生后才能继续执行。当某个外部事件发生时，线程被置回RUNNABLE状态，并可以再次被调度执行。**

> 当某个方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。Thread提供interrupt方法，用于中断线程或者查询线程是否已经被中断。

> 中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作，前提是线程B愿意停止下来。

> 同步工具类： 可以是任何一个对象，只要它根据自身的状态来协调线程的控制流。

- 闭锁：延迟线程的进度直到其到达终止状态，**到达结束状态后将不会再改变状态**。CountDownLatch：维护一个计数器(实际是AbstractQueuedSynchronizer的状态)，countDown()递减计数器，await()方法等待计数器达到0。

- FutureTask: 实现Future语义，表示一种抽象的可生产结果的计算。

Treiber stack : FutureTask中使用到了这种无锁并发栈,用来保存等待的线程，其实现方式是 CAS + 重试<br />
[FutureTask源码解读](http://www.cnblogs.com/micrari/p/7374513.html)

- Semaphore: 用来控制同时访问某个特定资源的操作数量，或同时执行某个指定操作的数量。

- 栅栏(Barrier): 阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须到达了栅栏位置，才能继续执行。闭锁用于等待事件(事件完成，线程允许执行)，而栅栏用于等待其他线程(所有线程到达栅栏，允许继续执行后面的操作)。

 CyclicBarrier: 栅栏可以重置，多次使用。
 ```java
  public CyclicBarrier(int parties);
  public CyclicBarrier(int parties, Runnable barrierAction);
  
  /* Waits until all parties have invoked await on this barrier.*/
  public int await() throws InterruptedException, BrokenBarrierException；
 ```
<br />
Exchanger: 两方(Two-Party)栅栏

```java
//实现一个缓存器
public interface Computable<A, V> {
	V compute(A args) throws InterruptedException;
}

public class Memoizer<A,V> implements Computable<A,V>{
	private final ConcurrentHashMap<A,FutureTask<V>> cache = 
			new ConcurrentHashMap<>();
	
	private final Computable<A,V> comp;
	
	public Memoizer(Computable<A,V> comp) {
		this.comp = comp;
	}
	
	public V compute(A args) throws InterruptedException {
		
		while(true) {
			FutureTask<V> f = cache.get(args);
			
			if(f == null) {
				Callable<V> callable = new Callable<V>() {
					@Override
					public V call() throws InterruptedException {
						return comp.compute(args);
					}
				};
				
				FutureTask<V> ft = new FutureTask<>(callable);
				
				f = cache.putIfAbsent(args, ft);
				
				if(f == null) {
					f = ft;
					ft.run();
				}
			}
			
			try {
				return f.get();
			} catch(CancellationException e) {
				cache.remove(args, f);  // Cache Pollution, removed
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
	}
}
```

-------
> 无限制地创建线程的问题：
 - 线程生命周期的开销非常高；
 - 资源消耗；如果可运行的线程数量多于可用的处理器数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他性能开销。如果已经有足够多的线程使所有CPU保持忙碌状态，那么再创建更多线程反而会降低性能。
 - 稳定性；在可创建线程的数量上存在一个限制，如果破坏这些限制，可能会抛出OutOfMemoryError。

> Executor框架：任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。在Java类库中，任务执行主要抽象不是Thread，而是Executor。**Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。任务的提交和执行解耦。**
```java
public interface Executor {
    void execute(Runnable command);
}
```

> 线程池：通过调用Executors中的静态方法创建线程池

- newFixedThreadPool
- newCachedThreadPool
- newSingleThreadExecutor
- newScheduledThreadPool

> Executor生命周期： 
 
为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口,Executor生命周期有3中状态：运行、关闭、已终止。
```java
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    Future<?> submit(Runnable task);
    <T> Future<T> submit(Runnable task, T result);
    <T> Future<T> submit(Callable<T> task);
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
}
```

------
> Runnable 、 Callable
```java
public interface Runnable {
// 不能返回值，不能抛出异常
    public abstract void run();  
}

public interface Callable<V> {
    V call() throws Exception;
}

```


```java

public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);
	boolean isCancelled();
	boolean isDone();
	V get() throws InterruptedException, ExecutionException;
	V get(long timeout, TimeUnit unit)
       	 throws InterruptedException, ExecutionException, TimeoutException;
}

```

> CompletionService : 将 Executor 和 BlockingQueue 功能融合。ExecutorCompletionService 是其实现类。

------
> 任务取消：java中没有一种安全的抢占式方法来停止线程，因此也没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。

**通常，中断是实现取消的最合理方式。**

> Thread中的中断方法：
 
```java
    public void interrupt(); // 中断目标线程
    public boolean isInterrupted(); // 返回目标线程的中断状态
    public static boolean interrupted(); // 清除当前线程的中断状态，并返回清除之前的值
    
```
中断操作并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。

> JVM 关闭：JVM 既可以正常关闭，也可以强行关闭。

正常关闭的触发方式包括：
- 最后一个"正常(非守护)"线程结束
- 调用System.exit()
- 通过其他特定于平台的方法关闭(如发送SIGINT信号或键入 Ctrl-C)

强行关闭：调用 Runtime,halt 或者在操作系统中"kill" JVM 进程(如发送SIGKILL)。

> 关闭钩子: 

```java
Runtime.getRuntime().addShutdownHook(Thread hook);
```

> 守护线程(Daemon Thread)：线程分为两种：普通线程和守护线程。在 JVM 启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程(如垃圾回收器以及其他执行辅助工作的线程)。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。

普通线程和守护线程的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM 会正常退出。当JVM 停止时，所有仍然存在的守护线程都将被抛弃(既不会执行finally代码块，也不会执行回卷栈，JVM只是直接退出)。

> finalize() ： **避免使用**

------

## 线程池： 
> 线程饥饿死锁(Thread Starvation Deadlock)：线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，除非线程池足够大，否则将发生线程饥饿死锁。

> 获取CPU数目：

```java
Runtime.getRuntime().availableProcessors();
```

> ThreadPoolExecutor:
 Executors中 newCachedThreadPool 和 newFixedThreadPool 返回的线程池都是 ThreadPoolExecutor 类型。
 
 **只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列可能导致线程"饥饿"死锁问题。此时，应该使用无界的线程池，如 Executors.newCachedThreadPool()。**
 
> 饱和策略：当有界队列被填满后，饱和策略开始发挥作用(如果某个任务被提交到一个已被关闭的Executor,也会用到饱和策略)。

JDk提供的饱和策略(均实现了 RejectedExecutionHandler 接口)：
- AbortPolicy ： 默认策略，抛出 RejectedExecutionException
- CallerRunsPolicy ：Executes task in the caller's thread, unless the executor has been shut down, in which case the task is discarded.
- DiscardPolicy ：新提交的任务无法保存到队列中等待执行时，悄悄抛弃该任务，do nothing
- DiscardOldestPolicy ： 抛弃下一个将被执行的任务，然后尝试重新提交新任务

```java
//ThreadPoolExecutor通过调用该方法修改饱和策略
public void setRejectedExecutionHandler(RejectedExecutionHandler handler);

// RejectedExecutionHandler 接口定义
public interface RejectedExecutionHandler {
	void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

> 线程工厂：线程池需要创建一个新线程时，调用ThreadFactory.newThread();默认的线程工厂方法创建一个新的、非守护的线程，并且不包含特殊的配置信息。

```java 
public interface ThreadFactory {
	Thread newThread(Runnable r);
}
```
