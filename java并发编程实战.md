#### Word List: 
 - civil engineering 土木工程
 - rivet 铆钉
 - I-beam 工字梁
 - fall down 失败；倒塌
 - means to an end 达到目的的手段
 - encompass 包含
 - externally 外部地；外表上
 - coordinate v.调节； n.坐标； adj.坐标的
 - corruption 贪污；腐败；堕落
 - mechanism 机制；原理
 - temptation 引诱；诱惑物
 - omit 省；，疏忽
 - trival 不重要的；琐碎的
 - retrofit 改进；更新
 - maintainable 可维护的
 - encapsulation 封装
 - invariant n.不变量；adj.不变的
 - at odds with 与..争执；意见不一致
 - compromise 妥协
 - sake 目的；利益；理由
 - compatibility 兼容性
 - legacy 遗产；遗留问题
 - not nearly 远非
 - pursue 继续；追赶；纠缠
 - realistic 现实的
 - adhere 坚持；依附；追随
 - dwarf adj.矮小的；v.变矮；n.矮子，侏儒
 - fragile 脆的，易碎的
 - characterize 描绘..特性；塑造人物
 - interchangeably 可交换地
 - thus far 迄今，现在为止
 - composition 作文；作曲；作品；构成；合成物；成分
 - make sense of 搞清..的意思
 - make sense to 对..合乎情理；有意义
 - make sense for 对..有意义
 - make sense out of 弄明白；理解
 - tricky 狡猾的；机警的；棘手的
 - intuitive 直觉的
 - counterintuitive 违反直觉的
 - downright 向下；完全地；(坏事)彻头彻尾的；(人的举止或行为)直率的；径直前进的
 - numerous 许多的
 - turn up 出现
 - no wonder 难怪
 - interaction 交互
 - suspiciously 怀疑地；猜测地
 - fuzzy 模糊的；失真的
 - conform 符合
 - constrain 约束
 - adequate 充足的；适当的；胜任的
 - convince 确信
 - interleave 交错；交叉
 - regardless of 不管；不顾
 - violate 违反；妨碍；侵犯
 - post-conditions 后置条件
 - stem from 起源于
 - facility 设施；设备；才能；天赋
 - factorization 因式分解
 - preserve 保留；保存
 - transient 短暂的
 - solely 单独地；仅仅
 - burden 负担
 - susceptible 易受影响的；敏感的
 - compact 袖珍的；紧凑的
 - indivisible 不可分割的
 - shorthand 速记
 - discrete 离散的；不连续的
 - derive from 源于
 - simultaneously 同时地
 - permanently 永久地
 - integrity 完整；正直；诚实
 - presence 存在；出席
 - arise 出现；发生
 - stand up 坚持；拥护；站得住脚
 - frustrated 沮丧的
 - nip 夹；捏；剪断；冻伤；阻止
 - idiom 习语
 - defer 推迟
 - undermine 破坏
 - vagary n.变换莫测
 - compound n.化合物，混合物；adj.混合的；v.合成，混合，恶化，和解，妥协
 - with respect to 相对于
 - prespective n.视角，远景，透视图；adj.透视的
 - either or 两者择一的
 - neither nor 既不是..也不是
 - refer 涉及；参考；查阅
 - collectively 集体地；共同地
 - necessarily 必要地；必然地；必定地
 - arbitrary 任意的；武断的；专制的
 - reason about 推出
 - consecutive 连续的
 - vulnerability 易损性；弱点
 - span v.跨越;n.跨度
 - guard 保卫；看守
 - mutual 共同的
 - intrinsic 本质的；固有的
 - fairly 相当地；公平地
 - extreme adj.极端的；n.极端
 - inhibit 阻止
 - be addressed 得到解决
 - basis 基础
 - acquisition 获得
 - stall n.货摊，畜栏，（房间内的）小隔间，车位，（车辆）熄火，（飞机）失速；v.熄火，拖延，暂缓
 - inherent 固有的；内在的；与生俱来的
 - convention 大会；惯例；约定；协定；习俗
 - throughout 自始至终；遍及
 - retrospect 回顾
 - tradeoff 权衡；折衷；（公平）交易
 - subvert 颠覆；推翻；破坏
 - audit 审计
 - ripple 波纹；涟漪
 - periodic 周期的；定期的
 - cure v.治疗，解决（问题）；n.药物，治疗
 - indiscriminate 任意的；无差别的
 - merely 仅仅，只不过
 - render v.致使，提供，提出，渲染
 - coarse-grained 粗鲁的；木纹粗糙的；粗略的；大概的
 - intend 打算
 - idle 闲置的
 - bonus 奖金；红利
 - constitute 构成；任命
 - portion n.部分；v.将..分配
 - revert 重新提到；回复
 - overhead n.经常性支出；adv.在头顶上方，在空中；adj.（费用开支等）日常的，在空中的
 - unduly 过度地；不适当地
 - tension n.张力，拉力，紧张，电压；v.使紧张，使拉紧
 - resist v.抵抗，忍耐；n.抗蚀剂
 - prematurely 过早地
 - sacrifice 牺牲
 - misconception 误解
 - demarcate 划分界线；区别
 - subtle 微妙的；精细的
 - intervene v.介于；adj.介于中间的
 - phenomenon 现象；奇迹；杰出人才
 - apparent 显然的；表面上的
 - in the absence of 缺少..时
 - weird 怪异的；不可思议的
 - insufficiently 不足地；不能胜任地
 - prohibitively 禁止地；过分地
 - scary 可怕的
 - stale 陈旧的
 - all or nothing 孤注一掷的；全部或一无所有的
 - edible adj.可食用的；n.食品
 - prevent 阻止；妨碍
 - analogous 类似的
 - hazard n.危害；v.使冒危险
 - out of thin air 无中生有地
 - prior 优先的
 - alternative 供选择的
 - propagate 传播；宣传；繁殖
 - roughly 大致；粗略地
 - anthropomorphized  给..赋予人性
 - cumbersome 笨重的
 - hoist v.升高，举起；n. 提升，起重

Writing thread-safe code is about managing access to **shared, mutable** state.


> java synchronization：

 - synchronized keywords： provide exclusive locking 
 - volatile variables
 - Explicit Lock
 - atomic variables

> if multiple threads access the same mutable state variable without appropriate synchronization, your program is broken. There are three ways to fix it: 

  - Don't share the state variable across thread;
  - Make the state variable immutable
  - Use synchronization whenever accessing the state variable
  

> Practice:

  It is always a good practice first to make your code right, and then make it fast. Even then, pursue optimization only if you performance measurements and requirements tell you that you must, and if those some measurements tell you that your optimization actually made a difference under realistic conditions.

a program that consists entirely of thread-safe class may not be thread-safe, and a thread-safe classes may contain classes that are not thread-safe.


> Thread-safe class:

 A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordinationon the part of the calling code. <br />

 No set of operations performed sequentially or concurrently on instances of a thread-safe class can cause an instance to be in an invalid state. <br />

 Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.

 Stateless objects are always thread-safe.

> Race Conditions

  A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime; in other words, when gettig the right answer relieson lucky timing. <br />

  The most common type of race condition is check-then-act, where a potentially stale observation is used to make a descision on what to do next.<br />

  To ensure thread safety, check-then-act operations (like lazy initialization) and read-modify-write operations (like increment) must always be atomic.

( **data race: arises when synchronization is not used to coordinate all access to a shared non-final field. Not all race conditions are data races, and not all data races are race conditions, but they both can cause concurrent programs to fail in unpredictable ways.** )

> synchronized:

``` java
  synchronized (lock) {
    // body 
  }
```
synchronized block has two parts:

 - a reference to an object that will serve as the lock (Synchronized method's lock is the object on which the mehtod is being invoked. Static synchronized methods use the Class object for the lock.)
 - a block of code to be guarded by that lock (synchronized method spans an entire method body)

> Intrinsic locks 

  Every Java object can implicitly act as a lock for purposes of synchronization; these built-in locks are called intrinsic locks or monitor locks. The lock is automatically acquired by the executing thread before entering a synchronized block and automatically released when control exits the synchronized block, whether by the normal control path or by throwing an exception out of the block.The only way to acquire an intrinsic lock is to enter a synchronized blcok or method guarded by that lock. <br />

  Intrinsic locks in Java act as mutexes (or mutual exclusion locks), which means that at most one thread may own the lock.<br />

  Intrinsic locks are reentrant, if a thread tries to acqire a lock that it already holds, the request succeeds.

> Serialized access:

  Serialized acess to an object has nothing to do with object serialization; serialized access means that threads take turns accessing the object exclusively, rather than doing so concurrently.

Every shared, mutable variable should be guardedd by exactly **one lock**.

There is frequently a tension between simplicity and performance.When implementing a synchronization policy, resist the temptation to prematurely sacrifice simplicity (potentially compromising safety) for the sake of performance.

Avoid holding locks during lengthy computations or operations at risk of not completing quickly such as network or console IO.

> Memory Visibility 

In order to ensure visibility of memory writes across threads, you must use synchronization.

> Reordering

There is no guarantee that operations in one thread will be performed in the order given by the program, as long as the reordering is not detectable from within that thread - even if the reordering is apparent to other threads.

> The Java Memory Model requires fetch and store operations to be atomic, bur for nonvolatile long and double variables, the JVM is permitted to treat a 64-bit read or write as two separate 32-bit operations.If the reads and writes occur in different threads, it is therefore possible to read a nonvolatile long and get back the high 32 bits of one value and the low 32 bits of another.

> Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all thread see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lcok.

> Volatile Variables 

When a field is declared volatile, the compiler and runtime are put on notice that this variable is shared and that operations on it should not be reordered with other memory operations.Volatile variables are not cached in registers or in caches where they are hidden from other processors, so a read of a volatile variable always returns the most recent write by any thread.<br />

Yet accessing a volatile variable perfroms no locing and so cannot cause the executing thread to block, making volatile variables a lighter-weight synchronization mechanism than synchronized. (Volatile reads are only slightly more expensive than nonvolatile reads on most current processor architectures.) <br />

Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when verifying correctness would require subtle reasoning about visibility. Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event(such as initialization or shutdown) has occurred. <br />

Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.<br />

You can use volatile variables only when all the following criteria are met:

- Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;
- The variable does not participate in invariants with other state variables;
- Locing is not required for any other reason while the variable is being accessed.

> Publication and Escape

> 发布(publish)与逸出(escape)： 发布一个对象是指使对象能在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况被称为逸出。
``` java
	public static Set<Secret> knownSecrets;
	
	public void initialize() {
		knownSecrets = new HashSet<Secret>();
	}
```
> 线程封闭： 当访问共享的可变数据时，通常需要同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。

- Ad-hoc 线程封闭： 维护线程封闭性的职责完全由程序实现来承担。(脆弱，少用)
- 栈封闭：只能通过局部变量才能访问对象。java语言的语义确保了基本类型的局部变量始终封闭在线程内；在维持对象引用的栈封闭性时需要额外工作确保被引用的对象不会逸出。
- ThreadLocal类：ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用该技术。(实现上ThreadLocal中存储值的对象ThreadLocalMap保存在相应线程的Thread对象中，当线程终止后，这些值会作为垃圾回收)。
``` java
 private static ThreadLocal<Connection> connectionHolder =
   new ThreadLocal<Connection>(){
       public Connection initialValue(){ // 某个线程初次调用ThreadLocal.get(),就会调用获取初始值
           return DriverManager.getConnection(DB_URL);
       }
   };
```
> 不变性： 不可变对象(immutable object)一定是线程安全的。

当满足以下条件时，对象才是不可变的：
 - 对象创建以后其状态就不能修改；
 - 对象的所有域都是final类型(从技术上来看，不可变对象并不需要将其所有的域都声明为final类型，如String的hash域)；
 - 对象是正确创建的(在对象的创建时期，this 没有逸出)；
 ```java
     public int hashCode() { // hash的计算推迟到第一次调用hashCode(),基于final域value,每次计算结果都相同
        int h = hash; 
        if (h == 0 && value.length > 0) {
            char val[] = value;
            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
 ```

> final 域：final类型的域是不能修改的(但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的)。在java内存模型中，final域有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。

**"除非需要更高的可见性，否则应将所有的域都声明为私有域"是一个良好的编程习惯；"除非需要某个域是可变的,否则应将其声明为final域"也是一个良好的编程习惯。**

> 在并发程序中使用和共享对象时，实用的一些策略：
 - 线程封闭： 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由该线程修改；
 - 只读共享： 在没有额外的同步情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象(Effectively Immutable Object, 对象从技术上来看是可变的，但其状态在发布后不会再改变)。
 - 线程安全共享： 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步；
 - 保护对象： 被保护的对象只能通过持有特定的锁访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

------
> 同步容器类：Vector 、Hashtable 、 Collections.synchronizedXxx() ， 实现线程安全的方式是将状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。

同步容器类都是线程安全的，但是在某些情况下可能需要额外的客户端加锁来保护符合操作。常见的符合操作：
- 迭代
- 跳转(根据指定顺序找到当前元素的下一个元素)
- 条件运算

在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。

> 迭代器(Iterator) 和 ConcurrentModificationException: 当发现容器在迭代过程中被修改，就会抛出一个ConcurrentModificationException (fail-fast机制)；实现上是将计数器的变化和容器关联，如果迭代期间计数器被修改，则抛出异常。(**在单线程代码中也可能抛出ConcurrentModificationException异常，当对象直接从容器中删除而不是通过Iterator.remove()来删除时就会抛出该异常。<remove()方法会修改exceptedModCount的值>**)

迭代过程中避免出现ConcurrentModificationException:
- 对容器加锁
- 克隆容器，在副本上进行迭代

容器的某些方法会间接地执行迭代操作，如hashCode(),equals()等，这些同样可能会抛出ConcurrentModificationException;

-------
> 并发容器： ConcurrentHashMap (替代同步且基于散列的Map), ConcurrentSkipListMap (替代同步的SortedMap), ConcurrentSkipListSet (替代同步的SortedSet), CopyOnWriteArrayList (在遍历操作为主要操作的情况下代替同步的List), ConcurrentLinkedQueue (FIFO队列),BlockingQueue (阻塞队列，"生产-消费者"模式)<PriorityQueue，优先队列，不是并发的>

- ConcurrentHashMap : jdk 7 : segment 实现，对整个Map进行计算的方法语义进行弱化，如size返回的结果可能已经过期，实际上只是个估计值；<br /> jdk 8 : CAS，synchronized 实现


 [为并发而生的 ConcurrentHashMap（Java 8）](https://www.jianshu.com/p/e99e3fcface4)
  <br />
 [为什么ConcurrentHashMap的读操作不需要加锁？](https://juejin.im/entry/5b98b89bf265da0abd35034c)
 
 并发容器提供的迭代器不会抛出 ConcurrentModificationException ,因此不需要在迭代过程中对容器加锁。ConcurrentHashMap 返回的迭代器具有**弱一致性** (Weaklly Consistent)，而并非"fail-fast"。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以(但不保证)在迭代器被构造后将修改操作反映给容器。
 <br />

- CopyOnWriteArrayList : 每次修改容器都会复制底层数组(并且使用 ReentrantLock )，所以仅当迭代操作远远多于修改操作时才应该使用。容器的迭代器保留一个指向底层数组的引用，由于底层数组不会被改变，所以对其进行同步只需确保数组内容的可见性。该容器的迭代器不会抛出 ConcurrentModificationException 。

- BlockingQueue 和 producer-consumer模式

```java
/* Inserts the specified element into this queue, waiting if necessary for space to become available. */
    void put(E e) throws InterruptedException;
    
/* Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. */    
    E take() throws InterruptedException;
```

| Implements | |
| - | - |
| ArrayBlockingQueue | FIFO，有界 |
| LinkedBlockingQueue | FIFO，有界或无界 |
| PriorityBlockingQueue | 有界，按优先级排序，自然序:Comparable 或 比较器：Comparator |
| SynchronousQueue | 同步队列，不为队列中的元素维护存储空间;它维护一组线程，这些线程在等待把元素加入或移出队列; 不是一个真正的队列，而是一种在线程之间进行移交的机制，Executors.newCachedThreadPool()使用了这种队列 |

队列可以是有界的，也可以是无界的，无界队列永远不会充满，因此无界队列上的 put 永远不会阻塞(通常这种无界不是真的无界，而是容量是Integer.MAX_VALUE)。
<br />
[解读 Java 并发队列 BlockingQueue](https://javadoop.com/2017/08/22/java-concurrent-queue/?)

**在构建高可用的应用程序时，有界队列是一种强大的资源管理工具，它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。**


> java 6 新增两个容器类型 ： Deque (发音"deck") 和 BlockingDeque, 分别对Queue和BlockingQueue进行扩展。实现类包括 ArrayDeque 和 LinkedBlockingDeque。 Deque 是一个双端队列，实现了在队列头和队列尾高效插入和移除。<br /> 双端队列适用的模式是**工作密取(Work Stealing)**:在生产者-消费者模式中，所有消费者有一个共享的工作队列，在工作密取中，每个消费者都有各自的双端队列。如果一个消费者完成自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。

------
线程状态转换：
![](https://github.com/CyC2018/CS-Notes/blob/master/pics/ace830df-9919-48ca-91b5-60b193f593d2.png)

> 阻塞方法和中断方法： 

线程阻塞(BLOCKED、WAITING、TIMED_WAITING)的一些原因： 
  - 等待I/O 操作结束
  - 等待获得锁
  - 等待从Thread.sleep方法中醒来
  - 等待另一个线程的计算结果

**阻塞操作与执行时间很长的普通操作的差别在于，被阻塞的线程必须等待某个不受它控制的事件发生后才能继续执行。当某个外部事件发生时，线程被置回RUNNABLE状态，并可以再次被调度执行。**

> 当某个方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。Thread提供interrupt方法，用于中断线程或者查询线程是否已经被中断。

> 中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作，前提是线程B愿意停止下来。

> 同步工具类： 可以是任何一个对象，只要它根据自身的状态来协调线程的控制流。

- 闭锁：延迟线程的进度直到其到达终止状态，**到达结束状态后将不会再改变状态**。CountDownLatch：维护一个计数器(实际是AbstractQueuedSynchronizer的状态)，countDown()递减计数器，await()方法等待计数器达到0。

- FutureTask: 实现Future语义，表示一种抽象的可生产结果的计算。

Treiber stack : FutureTask中使用到了这种无锁并发栈,用来保存等待的线程，其实现方式是 CAS + 重试<br />
[FutureTask源码解读](http://www.cnblogs.com/micrari/p/7374513.html)

- Semaphore: 用来控制同时访问某个特定资源的操作数量，或同时执行某个指定操作的数量。

- 栅栏(Barrier): 阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须到达了栅栏位置，才能继续执行。闭锁用于等待事件(事件完成，线程允许执行)，而栅栏用于等待其他线程(所有线程到达栅栏，允许继续执行后面的操作)。

 CyclicBarrier: 栅栏可以重置，多次使用。
 ```java
  public CyclicBarrier(int parties);
  public CyclicBarrier(int parties, Runnable barrierAction);
  
  /* Waits until all parties have invoked await on this barrier.*/
  public int await() throws InterruptedException, BrokenBarrierException；
 ```
<br />
Exchanger: 两方(Two-Party)栅栏

```java
//实现一个缓存器
public interface Computable<A, V> {
	V compute(A args) throws InterruptedException;
}

public class Memoizer<A,V> implements Computable<A,V>{
	private final ConcurrentHashMap<A,FutureTask<V>> cache = 
			new ConcurrentHashMap<>();
	
	private final Computable<A,V> comp;
	
	public Memoizer(Computable<A,V> comp) {
		this.comp = comp;
	}
	
	public V compute(A args) throws InterruptedException {
		
		while(true) {
			FutureTask<V> f = cache.get(args);
			
			if(f == null) {
				Callable<V> callable = new Callable<V>() {
					@Override
					public V call() throws InterruptedException {
						return comp.compute(args);
					}
				};
				
				FutureTask<V> ft = new FutureTask<>(callable);
				
				f = cache.putIfAbsent(args, ft);
				
				if(f == null) {
					f = ft;
					ft.run();
				}
			}
			
			try {
				return f.get();
			} catch(CancellationException e) {
				cache.remove(args, f);  // Cache Pollution, removed
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
	}
}
```

-------
> 无限制地创建线程的问题：
 - 线程生命周期的开销非常高；
 - 资源消耗；如果可运行的线程数量多于可用的处理器数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他性能开销。如果已经有足够多的线程使所有CPU保持忙碌状态，那么再创建更多线程反而会降低性能。
 - 稳定性；在可创建线程的数量上存在一个限制，如果破坏这些限制，可能会抛出OutOfMemoryError。

> Executor框架：任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。在Java类库中，任务执行主要抽象不是Thread，而是Executor。**Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。任务的提交和执行解耦。**
```java
public interface Executor {
    void execute(Runnable command);
}
```

> 线程池：通过调用Executors中的静态方法创建线程池

- newFixedThreadPool
- newCachedThreadPool
- newSingleThreadExecutor
- newScheduledThreadPool

> Executor生命周期： 
 
为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口,Executor生命周期有3中状态：运行、关闭、已终止。
```java
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    Future<?> submit(Runnable task);
    <T> Future<T> submit(Runnable task, T result);
    <T> Future<T> submit(Callable<T> task);
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
}
```

------
> Runnable 、 Callable
```java
public interface Runnable {
// 不能返回值，不能抛出异常
    public abstract void run();  
}

public interface Callable<V> {
    V call() throws Exception;
}

```


```java

public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);
	boolean isCancelled();
	boolean isDone();
	V get() throws InterruptedException, ExecutionException;
	V get(long timeout, TimeUnit unit)
       	 throws InterruptedException, ExecutionException, TimeoutException;
}

```

> CompletionService : 将 Executor 和 BlockingQueue 功能融合。ExecutorCompletionService 是其实现类。

------
> 任务取消：java中没有一种安全的抢占式方法来停止线程，因此也没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。

**通常，中断是实现取消的最合理方式。**

> Thread中的中断方法：
 
```java
    public void interrupt(); // 中断目标线程
    public boolean isInterrupted(); // 返回目标线程的中断状态
    public static boolean interrupted(); // 清除当前线程的中断状态，并返回清除之前的值
    
```
中断操作并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。

> JVM 关闭：JVM 既可以正常关闭，也可以强行关闭。

正常关闭的触发方式包括：
- 最后一个"正常(非守护)"线程结束
- 调用System.exit()
- 通过其他特定于平台的方法关闭(如发送SIGINT信号或键入 Ctrl-C)

强行关闭：调用 Runtime,halt 或者在操作系统中"kill" JVM 进程(如发送SIGKILL)。

> 关闭钩子: 

```java
Runtime.getRuntime().addShutdownHook(Thread hook);
```

> 守护线程(Daemon Thread)：线程分为两种：普通线程和守护线程。在 JVM 启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程(如垃圾回收器以及其他执行辅助工作的线程)。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。

普通线程和守护线程的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM 会正常退出。当JVM 停止时，所有仍然存在的守护线程都将被抛弃(既不会执行finally代码块，也不会执行回卷栈，JVM只是直接退出)。

> finalize() ： **避免使用**

------

## 线程池： 
> 线程饥饿死锁(Thread Starvation Deadlock)：线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，除非线程池足够大，否则将发生线程饥饿死锁。

> 获取CPU数目：

```java
Runtime.getRuntime().availableProcessors();
```

> ThreadPoolExecutor:
 Executors中 newCachedThreadPool 和 newFixedThreadPool 返回的线程池都是 ThreadPoolExecutor 类型。
 
 **只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列可能导致线程"饥饿"死锁问题。此时，应该使用无界的线程池，如 Executors.newCachedThreadPool()。**
 
> 饱和策略：当有界队列被填满后，饱和策略开始发挥作用(如果某个任务被提交到一个已被关闭的Executor,也会用到饱和策略)。

JDk提供的饱和策略(均实现了 RejectedExecutionHandler 接口)：
- AbortPolicy ： 默认策略，抛出 RejectedExecutionException
- CallerRunsPolicy ：Executes task in the caller's thread, unless the executor has been shut down, in which case the task is discarded.
- DiscardPolicy ：新提交的任务无法保存到队列中等待执行时，悄悄抛弃该任务，do nothing
- DiscardOldestPolicy ： 抛弃下一个将被执行的任务，然后尝试重新提交新任务

```java
//ThreadPoolExecutor通过调用该方法修改饱和策略
public void setRejectedExecutionHandler(RejectedExecutionHandler handler);

// RejectedExecutionHandler 接口定义
public interface RejectedExecutionHandler {
	void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

> 线程工厂：线程池需要创建一个新线程时，调用ThreadFactory.newThread();默认的线程工厂方法创建一个新的、非守护的线程，并且不包含特殊的配置信息。

```java 
public interface ThreadFactory {
	Thread newThread(Runnable r);
}
```
