#### Word List: 
 - civil engineering 土木工程
 - rivet 铆钉
 - I-beam 工字梁
 - fall down 失败；倒塌
 - means to an end 达到目的的手段
 - externally 外部地；外表上
 - coordinate v.调节； n.坐标； adj.坐标的
 - corruption 贪污；腐败；堕落
 - mechanism 机制；原理
 - temptation 引诱；诱惑物
 - omit 省；，疏忽
 - trival 不重要的；琐碎的
 - retrofit 改进；更新
 - maintainable 可维护的
 - encapsulation 封装
 - invariant n.不变量；adj.不变的
 - at odds with 与..争执；意见不一致
 - compromise 妥协
 - sake 目的；利益；理由
 - compatibility 兼容性
 - legacy 遗产；遗留问题
 - not nearly 远非
 - pursue 继续；追赶；纠缠
 - realistic 现实的
 - adhere 坚持；依附；追随
 - dwarf adj.矮小的；v.变矮；n.矮子，侏儒
 - fragile 脆的，易碎的
 - characterize 描绘..特性；塑造人物
 - interchangeably 可交换地
 - thus far 迄今，现在为止
 - composition 作文；作曲；作品；构成；合成物；成分
 - make sense 有意义
 - make sense of 搞清..的意思
 - make sense to 对..合乎情理；有意义
 - make sense for 对..有意义
 - make sense out of 弄明白；理解
 - in a sense 在某种意义上
 - tricky 狡猾的；机警的；棘手的
 - intuitive 直觉的
 - counterintuitive 违反直觉的
 - downright 向下；完全地；(坏事)彻头彻尾的；(人的举止或行为)直率的；径直前进的
 - numerous 许多的
 - turn up 出现
 - no wonder 难怪
 - interaction 交互
 - suspiciously 怀疑地；猜测地
 - fuzzy 模糊的；失真的
 - conform 符合
 - constrain 约束
 - adequate 充足的；适当的；胜任的
 - convince 确信
 - interleave 交错；交叉
 - regardless of 不管；不顾
 - violate 违反；妨碍；侵犯
 - post-conditions 后置条件
 - stem from 起源于
 - facility 设施；设备；才能；天赋
 - factorization 因式分解
 - preserve 保留；保存
 - transient 短暂的
 - solely 单独地；仅仅
 - burden 负担
 - susceptible 易受影响的；敏感的
 - compact 袖珍的；紧凑的
 - indivisible 不可分割的
 - shorthand 速记
 - discrete 离散的；不连续的
 - derive from 源于
 - simultaneously 同时地
 - permanently 永久地
 - integrity 完整；正直；诚实
 - presence 存在；出席
 - arise 出现；发生
 - stand up 坚持；拥护；站得住脚
 - frustrated 沮丧的
 - nip 夹；捏；剪断；冻伤；阻止
 - idiom 习语
 - defer 推迟
 - undermine 破坏
 - vagary n.变换莫测
 - compound n.化合物，混合物；adj.混合的；v.合成，混合，恶化，和解，妥协
 - with respect to 相对于
 - prespective n.视角，远景，透视图；adj.透视的
 - either or 两者择一的
 - neither nor 既不是..也不是
 - neither of 没有一个
 - refer 涉及；参考；查阅
 - collectively 集体地；共同地
 - necessarily 必要地；必然地；必定地
 - arbitrary 任意的；武断的；专制的
 - reason about 推出
 - consecutive 连续的
 - vulnerability 易损性；弱点
 - span v.跨越;n.跨度
 - guard 保卫；看守
 - mutual 共同的
 - intrinsic 本质的；固有的
 - fairly 相当地；公平地
 - extreme adj.极端的；n.极端
 - inhibit 阻止
 - be addressed 得到解决
 - basis 基础
 - acquisition 获得
 - stall n.货摊，畜栏，（房间内的）小隔间，车位，（车辆）熄火，（飞机）失速；v.熄火，拖延，暂缓
 - inherent 固有的；内在的；与生俱来的
 - convention 大会；惯例；约定；协定；习俗
 - throughout 自始至终；遍及
 - retrospect 回顾
 - tradeoff 权衡；折衷；（公平）交易
 - subvert 颠覆；推翻；破坏
 - audit 审计
 - ripple 波纹；涟漪
 - periodic 周期的；定期的
 - cure v.治疗，解决（问题）；n.药物，治疗
 - indiscriminate 任意的；无差别的
 - merely 仅仅，只不过
 - render v.致使，提供，提出，渲染
 - coarse-grained 粗鲁的；木纹粗糙的；粗略的；大概的
 - intend 打算
 - idle adj.闲置的，懒惰的；v.虚度，使空转，无所事事
 - bonus 奖金；红利
 - constitute 构成；任命
 - portion n.部分；v.将..分配
 - revert 重新提到；回复
 - overhead n.经常性支出；adv.在头顶上方，在空中；adj.（费用开支等）日常的，在空中的
 - unduly 过度地；不适当地
 - tension n.张力，拉力，紧张，电压；v.使紧张，使拉紧
 - resist v.抵抗，忍耐；n.抗蚀剂
 - prematurely 过早地
 - sacrifice 牺牲
 - misconception 误解
 - demarcate 划分界线；区别
 - subtle 微妙的；精细的
 - intervene v.介于；adj.介于中间的
 - phenomenon 现象；奇迹；杰出人才
 - apparent 显然的；表面上的
 - in the absence of 缺少..时
 - weird 怪异的；不可思议的
 - insufficiently 不足地；不能胜任地
 - prohibitively 禁止地；过分地
 - scary 可怕的
 - stale 陈旧的
 - all or nothing 孤注一掷的；全部或一无所有的
 - edible adj.可食用的；n.食品
 - prevent 阻止；妨碍
 - analogous 类似的
 - hazard n.危害；v.使冒危险
 - out of thin air 无中生有地
 - prior 优先的
 - alternative 供选择的
 - propagate 传播；宣传；繁殖
 - roughly 大致；粗略地
 - anthropomorphized  给..赋予人性
 - cumbersome 笨重的
 - hoist v.升高，举起；n. 提升，起重
 - blatant 喧嚣的；公然的；炫耀的；显眼的
 - indirectly 间接地
 - abbreviation 缩写
 - misuse 误用
 - maliciously 有敌意地；恶意地
 - carelessly 粗心地
 - compelling 引人注目的；令人信服的；不可抗拒的
 - compel v.强迫
 - steal 偷窃
 - mischief 恶作剧；伤害
 - confinement 限制
 - swing n.摇摆，秋千；adj.旋转的，悬挂的，强节奏爵士音乐的；v.摇摆，转向，悬挂
 - extensively 广阔地；广泛地
 - dispatch 派遣；发送
 - other than 除了
 - dispense 分发；免除
 - enforce 实施；执行；强制
 - responsibility 责任；义务
 - responsiveness n.响应能力，有同情心
 - even with 即使有
 - outweight 比..重要
 - sparingly 节俭地；保守地；爱惜地
 - primitively 最初地；原始地
 - associate v.联系，关联；n.伙伴，联想；adj.联合的，副的
 - straightforward 简单的；直截了当地
 - mundane 平凡的；世俗的；宇宙的；世界的
 - consult 请教；咨询
 - conceptually 概念上
 - port n.港口，口岸，端口，舱门，左舷；v.持（枪），左转舵
 - abuse 滥用
 - property 性质；性能；财产；所有权
 - detract 贬低；减去；转移；使分心
 - reusability 可重用性
 - couple n.对，夫妇；v.结合，连接，成婚
 - buggy 多虫的
 - delicate 微妙的；精美的；可口的
 - benign 良性的；和蔼的；吉利的
 - unwarranted 无根据的；无保证的
 - eliminate 消除，排除
 - interfere 干涉；妨碍；冲突；介入
 - harmless 无害的；无恶意的
 - immune adj.免疫的，免于..的；n.免疫者
 - entail 需要
 - for the moment 暂时；暂且；目前
 - fulfill 满足
 - engagement 婚约；约会；诺言；参与度
 - compose 组成；构成；作曲；写作
 - comprise 包含，由..组成
 - encompass 包含；环绕
 - take on 承担
 - derive 源于；导出
 - impose 强加；利用
 - transition 过渡；转变
 - underlying 潜在的；根本的
 - obey 服从
 - precondition 先决条件
 - tightly 紧紧地
 - implied 暗指的；隐式的 
 - embody 体现；具体表达
 - ownership 所有权
 - short-term 短期的
 - long-term 长期的
 - loan n.贷款；v.借
 - envision 想象；预想
 - joint adj.联合的，合办的，共同拥有的；n.关节，接合处，（非正式）娱乐场所；v.连接
 - precise 精确的；严格的
 - exhibit n.展览品，展览会，证据；v.展览，提出（证据等）
 - infrastructure 基础设施；公共建设
 - safekeep 保护
 - passivation 钝化处理
 - discipline n.学科，纪律，训练，惩罚；v.训练，惩戒
 - so long as 只要
 - inspire 激发；鼓舞
 - sophisticated 复杂的；久经世故的
 - scalability 扩展性
 - widget 装饰品；小部件
 - fleet adj.快速的，敏捷的，（水）浅的；n.船队，舰队，海军，车队，小河，水道，沟；v.（诗歌或文学）飞逝，疾驰，使（时间）飞快地过去，消失，转瞬即逝 
 - concise 简明的
 - taxicab 出租车
 - manually 手动地
 - drawback 缺点，不利条件，退税
 - degrade 降低
 - scratch n.擦伤，抓痕；v.抓，刮，乱涂；adj.打草稿用的，凑合的
 - substantial adj.大量的，实质的；n.本质，重要材料
 - liability 责任；债务；倾向；可能性；不利因素
 - shallow n.浅滩；adj.浅的，肤浅的；v.变浅
 - accommodate 容纳；适应；调解
 - at once 立刻；马上
 - building block 积木；构件
 - effort 努力；成就
 - bell n.铃；v.系铃
 - warning bell 警铃
 - go off 离开；爆炸；动身
 - interpretation 解释；翻译；演出
 - facilitate 促进；帮助；使容易
 - comprehension n.理解；包含
 - admit 承认；容许
 - subtly 精细地；巧妙地
 - suffer from 忍受；遭受
 - functionality 功能；函数性
 - illusion 幻觉；错觉
 - albeit 虽然；尽管
 - obliquely 倾斜地；转弯抹角地
 - penalty 罚款；罚金；处罚
 - mimic v.模仿；adj.模仿的；n.模仿者
 - outstanding 杰出的；显著的；未解决的
 - contend 竞争；斗争；争论；主张
 - underutilize 未充分利用
 - inadvertently 无意地；不经意地
 - constituency 选民；支持者
 - blur v.变模糊；沾上污迹；n.模糊不清的事物；污迹
 - craft n.工艺，太空船；v.精巧地制作
 - affair 事情；绯闻；私事
 - clue n.线索；v.为..提供线索
 - woefully 悲伤地；不幸地
 - prudence n.审慎，谨慎
 - ought to 应该
 - intuition 直觉
 - neglect n.忽视，忽略；v.忽视，忽略
 - erroneous 错误的；不正确的
 - vague 模糊的
 - forthcoming n.来临；adj.即将来临的
 - vendor 卖主；小贩；供应商；自动售货机
 - compliant 顺从的；服从的；应允的
 - frustratingly 令人泄气地；令人沮丧地
 - omission 省略
 - despite prep.即使，尽管；n.侮辱，轻视
 - revision 修订本
 - as opposed to 与..截然相反；对照
 - merely 仅仅
 - absurd n.荒诞，荒诞作品；adj.荒谬的，可笑的
 - bolster v.支持，支撑，改善，给（座位）加软垫；n.垫枕，托木，支持
 - replication 复制；回答；反响
 - take responsibility for 对..负责
 - exhausted adj.精疲力尽的，耗尽的；v.使..精疲力尽，耗尽
 - navigation 航行；航海
 - corrupt adj.腐败的，堕落的；v.腐烂，堕落
 - opinion 意见；主张
 - shrink v.收缩；缩小，退缩，（衣服）缩水；n.心理医生，收缩，畏缩
 - leap v.跳跃，猛冲，剧增；n.跳跃，剧增
 - in conformance with 与..一致；符合
 - impair 损害；削弱；减少
 - clarity 清楚；明晰；透明
 - obviate 排除；避免
 - foolproof 极简单的
 - indicator 指示器；指示灯
 - deliberate adj.故意的，深思熟虑的，从容的；v.仔细考虑，商议
 - starvation 饿死；挨饿；绝食
 - throughput 吞吐量
 - utilization 利用率；利用
 - favorable 有利的；良好的；赞成的
 - bold 大胆的；英勇的；黑体的；险峻的
 - concatenation 连接；串联
 - dominant 占优势的；统治的
 - retrieval n.检索，取回，恢复，拯救
 - spread out 展开；传播
 - unevenly 不均衡地；不平坦地
 - degenerate v.退化，恶化，堕落；adj.退化的，堕落的；n.堕落的人
 - strip v.脱去衣服，剥去（外皮），拆卸，剥夺，修剪（树枝）；n.条状物，脱衣舞，（纸、金属、织物等）带
 - along with 沿着；与..一道
 - estimate 估计；评估
 - approximation 近似值
 - continuously 连续不断地
 - drop-in adj.不用预约的，立即使用的；n.非正式造访，不速之客
 - briefly 短暂的；简略的；暂时的
 - criterion （批评判断的）标准；准则；规范
 - deliver 发表；投递；释放
 - as well as 也；和..一样
 - equivalent n.对等的人，当量；adj.等价的
 - workload 工作量
 - rate n.比率，速度，价格，等级；v.认为，估价，责骂，被评价 
 - labor n.劳动，工作，分娩；v.劳动，努力，使厌烦，详细分析 
 - rack n.架子，拷问台，齿条；v.变形，折磨，榨取，小步跑 
 - dry adj.干的，口渴的；n.干涸；v.变干
 - fill up 装满
 - analogy n.类比，类推
 - sink v.下沉；n.水槽
 - crawler 爬行者；爬虫
 - eventually 最后；终于
 - catch up 赶上；追上
 - shed n.小屋，棚，分水岭；v.流出，脱落，散布
 - excess adj.额外的，过量的；n.超过，过度
 - throttle n.节流阀，喉咙；v.节流，窒息
 - robust 强健的；粗野的
 - threaten 威胁；恐吓
 - keep up 保持；继续；不落后
 - rearchitect 重构
 - up front 预先
 - feed back 反馈
 - amenable 有责任的；有义务的；顺从的；经得起检验的
 - decomposition n.分解，腐烂，变质
 - agent n.代理人，代理商，特工 ；v.由..代理，由..作中介；adj.代理的
 - hierarchy 层级；等级制度
 - monolithic adj.整体的，庞大的；n.单片电路
 - yield v.生产；产出，屈服，放弃，停止争论，给..让路；n.产量，利润
 - overall adj.全部的；adv.总的来说；n.工装裤，罩衫
 - exploit n.功绩；v.开发，开采，剥削
 - eligible n.合格者，有资格者；adj.合格的，符合条件的
 - sensible 明智的；合乎情理的
 - get away with 侥幸成功
 - deprive 使丧失，剥夺
 - swallow v.忍受，吞没，咽下；n.燕子，一次吞咽的量
 - in bulk 整批；散装；大批；大量
 - gate n.大门，出入口，门道；v.给..装大门
 - bother with 为..费心；用..打扰
 - presumably 大概；推测起来；可假定
 - vary v.改变；变化；违反；使多样化
 - bear v.忍受，承受，不适于某事，承担责任，经得起，坏心情，支持，携带，生（孩子），产生（利息）；n.熊，泰迪熊
 - subsume 把..归入；把..包含在内
 - convey 传达；运输
 - lengthy 漫长的；冗长的；啰嗦的
 - inadvisable 失策的；不明智的
 - coerce 强制；迫使
 - rendezvous n.约会，约会地点，集结地；v.会合，约会，在指定地点与..相会
 - elect v.选举，选择，决定（做某事）；adj.卓越的，当选（而尚未就职的）的；n.被选的人
 - trip n.旅行，赛程，绊倒，错误，（机器、电路的）开关，奇妙有趣的经历；v.绊倒，（部分电路）自动断开，触发（开关）
 - particle 颗粒；[物]质点；极小量
 - cellular n.移动电话，单元；adj.细胞的，多孔的
 - automata 自动机；不动脑筋机械行事的人；自动装置；小机器人（automaton的复数）
 - asymmetric 不对称的
 - bottleneck 瓶颈；障碍物
 - conservative n.保守派，守旧者；adj.保守的
 - sort v.分类，协调，交往；n.种类，方式，品质，分类，排序
 - awful adj.可怕的，极坏的，极讨厌的，使人敬畏的，非常的；adv.极其，非常
 - defect n.缺点；v.变节，叛变
 - far worse 糟糕得多
 - notion 概念，见解，打算
 - head over to 前往
 - hang out 闲逛
 - transparent 透明的，显然的，坦率的，易懂的
 - eviction 逐出，赶出，收回
 - material adj.物质的，身体需要的，重要的，（证据或事实）决定性的，客观存在的，物欲的；n.材料，用具，（有指明特征的）人才，素材，曲目，布料
 - cheat n.欺骗，作弊，骗子；v.欺骗，作弊
 - headquarter 总部，司令部，总公司
 - campaign v.领导或参加运动，参见竞选；n.运动，活动，战役，竞选
 - boil down to 归结于
 - tremendously 非常地；可怕地；惊人地
 - defensive n.防御，守势；adj.自卫的，防御用的
 - comply 遵守；顺从；应允
 - clever 聪明的；机灵的；熟练的 
 - ideally 理想地；观念上地
 - fraction 分数；部分；小部分；稍微
 - provision n.规定，条款，供应品；v.供给..食物和必需品
 - grateful 感谢的；令人愉快的；宜人的
 - graceful 优雅的；优美的
 - degradation n.退化；降级；堕落
 - fall over 跌倒
 - percentage 百分比；百分数
 - potential n.潜能，可能性；adj.潜在的；可能的
 - theoretically 理论地；理论上
 - alternate v.交替，轮流；adj.交替的，轮流的，间隔的，每隔（..天等）的，另外的，可供选择的，（两者）互不相容的，另类的，非传统的，（叶、芽）互生的；n.替换物，代理人
 - congestion 拥挤；拥塞；淤血
 - pend n.拱道；v.等候判定，悬挂，垂下
 - moderate adj.稳健的，温和的，适度的，中等的，有节制的；v.节制，减轻，变缓和
 - teardown n.拆卸，待拆房屋
 - tie up 占用；包扎；绑好；阻碍；密切联系；合伙；停泊
 - tie n.领带，鞋带，领结，关系，纽带，束缚，平局，（英）淘汰赛（尤指足球）；v.（用线、绳等）系，打结，连接，联合，约束，与..平局，不分胜负 
 - megabyte 兆字节
 - prototype n.原型，样本，标准，模范；v.制作原型 
 - surface n.表面，外观；adj.肤浅的，表面的；v.浮出水面是，使成平面 
 - gather n.聚集，衣褶，收获量；vt.收集，收割，使..聚集，使..皱起，聚集 
 - hook n.挂钩，吊钩；v.钩住，弯成钩状 
 - substitute n.代替者，代用品；v.替代 
 - invasive 侵入的；入侵的；扩散的
 - tend to 趋向；易于
 - strew 散播；撒满
 - specify 指定；详细说明；列举；把..列入说明书 
 - victim n.受害人，牺牲品，牺牲者，受骗者，上当的人，祭品，牺牲，无助者，被动者
 - scarce adj.缺乏的，不足的，稀有的；adv.仅仅，几乎不，几乎没有 
 - practical 实际的；实用的
 - homogeneous 均匀的；同类的 
 - amortize 摊销；分期偿还
 - tune n.曲调，和谐，心情；v.调整，使一致，为..调音，协调 
 - thrash n.打谷，逆风浪行进，踢水动作；v.打，使逆行，打谷，猛烈摆动 
 - reap 收获；收割
 - spectrum 光谱；范围
 - abrupt 生硬的；突然的；唐突的；陡峭的
 - imply v.意味，暗示，隐含
 - discard n.抛弃，被丢弃的东西或人；v.抛弃，放弃
 - recur v.复发，循环，重现，递归
 - accuracy 精确度；准确性
 - resurrect 复活；复兴
 - leakage 泄露；渗漏物
 - exploitable 可开发的；可利用的
 - intersperse 散布；点缀；在..中夹杂某物 
 - dimension n.方面，维度，尺寸，次元，容积；adj.规格的；v.标出尺寸 
 - markup n.涨价，利润，审定 
 - placeholder 占位符
 - rectangular 矩形的
 - anticipate v.预期，预料，期盼，先于..做，早于..行动，在期限内履行（义务），偿还（债务），提前使用 
 - express n.快车，快递，捷运公司；v.表达，快递；adj.明确的，迅速的，专门的
 - cooperate v.合作，配合，协力 
 - get a head start 良好的开端
 - heterogeneous adj.由很多种类组成的，混杂的，各种各样的，（化学）不均一的，多相的，（数学）不纯一的，参差的 
 - scale n.规模，比例，鳞，刻度，天平，数值范围；v.测量，攀登，剥落，生水垢，改变大小，刮鳞，依比例决定  
 - show up 露面；露出；揭露
 - get in the way 妨碍；阻碍
 - division n.除法，部门，分配，分割，师（军队），赛区 
 - finer-grained 细粒度
 - diminish v.减少，缩小 
 - disparate n.无法相比的东西；adj.不同的，不相干的，全异的 
 - worthwhile adj.重要的，值得的，有价值的
 - compensate v.补偿，赔偿，抵消，付报酬 
 - payoff adj.支付的，决定性的，产生结果的；n.报酬，结果，发工资，结算 
 - tedious 沉闷的，冗长乏味的 
 - portal n.大门，入口
 - budget n.预算；adj.廉价的；v.安排，预定，把..编入预算，做预算 
 - abort n.中止计划；v.使中止，流产，堕胎，夭折，发育不全 
 - expire v.期满，终止，死亡，呼吸，呼出（空气） 
 - reservation 保留；预定
 - generalize v.形成概念，概括，归纳，推广，使..一般化 
 - bid n.出价，投标，努力，叫牌；v.出价，叫牌，向..表示问候，（诗、文）命令，邀请，努力争取，企图获得，告诉，吩咐 
 - airline n.航空公司，航线；adj.航线的
 - rental n.租金收入，租金，租赁，租用的房屋（或汽车、设备等）；adj.租赁的，收取租金的 
 - identical n.完全相同的事物；adj.同一的，完全相同的 
 - whereas conj.然而，鉴于；n.序言，开场白，条件语句 
 - flawed 有缺陷的；有瑕疵的；有裂纹的
 - rarely 很少地；罕有地
 - preemptively 先发制人地 
 - agreed-upon 一致同意的 
 - enumerate v.列举，枚举，计算
 - take a while 需要一段时间
 - get ahead of 胜过；领先
 - emerge 浮现；摆脱；暴露 
 - sustain 维持；支撑；承担；忍受；供养；证实 
 - sticky 粘性的
 - trigger n.扳机，起因，触发器；v.触发，引起 
 - persist v.坚持，持续，固执 
 - deliberately 故意地
 - deny v.否认，拒绝 
 - restrict 限制；约束
 - recipient n.容器，接受者，容纳者；adj.容易接受的，容纳的 
 - house-sit （主人外出时）代为照看房子 
 - mail n.邮件，邮政，邮递，盔甲；v.邮寄，给..穿盔甲
 - throw out 扔掉；伸出；说出；否决；突出 
 - postpone 延缓；把..放在次要位置
 - opportune 适当的；恰好的  
 - critic 批评家，评论家，爱挑剔的人
 - deride 嘲笑；嘲弄  
 - robustness 鲁棒性；稳健性；健壮性 
 - higher-up 上级；上司；大人物
 - take forever 花很长时间 
 - somewhat adv.有点，稍微；pron.某物，几分 
 - appealingly 上诉地；哀求地；吸引人地 
 - irritate v. 刺激，使兴奋，激怒，过敏
 - deficiency 缺陷；缺点 
 - refine 精炼；提纯；改善；使..文雅 
 - persuade v.说服
 - dictate n.命令，指示；v.命令，口述，听写  
 - transitive n.传递，及物动词；adj.及物的，过渡的，可传递的 
 - dedicated adj.专用的，专注的，献身的；v.以..奉献，把..用于 (dedicate) 
 - drain n.排水沟，下水道，负担，消耗；v.排水，流干，喝光，（感情）变淡，耗尽 
 - likelihood 可能性
 - variant adj.不同的，多样的；n.变体，转化  
 - poison n.毒药，极有害的思想；v.毒害，下毒，败坏，污染（地区、空气等），抑制..的活性 
 - pill n.药丸，弹丸，子弹；v.制成丸剂，服药丸，抢劫，掠夺 
 - unwieldy 笨拙的；笨重的
 - preclude 排除；妨碍；阻止
 - commence v.开始，着手，<英>获得学位 
 - instrument n.仪器，工具，乐器，手段，器械；v.给..装测量仪器 
 - idempotent n.幂等；adj.幂等的 
 - abnormal 反常的；不规则的；变态的
 - disastrous 灾难性的；损失惨重的；悲伤的 
 - freeze v.冻结，结冰，冷冻，冷藏，惊呆，使定格；n.冻结，凝固，停止，冰冻期，霜冻
 - commission n.委员会，佣金，服务费，犯，委任，委任状；v.委任，使服役  
 - out of commission 损坏的；退役的；不能使用的
 - take a leap of faith 信心剧增
 - skeptical 怀疑的；多疑的；（哲学）怀疑论的
 - be informed of 听说
 - corrective n.矫正物，改善法；adj.矫正的，惩治的
 - controversy n.争论，论战，辩论 
 - proactive 前摄的；有前瞻性的；主动的；先行一步的 
 - complementary 补足的；辅助性的；补充的；互补的 
 - indepth 深入的；彻底的
 - bubble n.气泡，泡沫，泡状物，圆形顶；v.冒泡，发出气泡声，沸腾，滔滔不绝地说 
 - diagnostic n.诊断法，诊断结论；adj.诊断的，特征的 
 - daemon 守护进程；后台程序 
 - halt n.停止，（英）小火车站，瘸，（口令）立定；adj.瘸的；v.停止，立定，突然停下，完全停止，犹豫，跛行，(尤指逻辑或诗韵)有缺陷
 - inventory n.存货，存货清单，详细目录，财产清册
 - wound n.创伤，伤口；v.使受伤，伤害  
 - unwound adj.未上发条的，松散的；v.松开(unwind的过去式和过去分词)，解开
 - wind n.风，呼吸，气味，卷绕；v.缠绕，上发条，使弯曲，吹号角 
 - reclaim n.改造，感化；v.开拓，回收再利用，改造某人，抗议，喊叫 
 - nontrivial 重要的
 - overstatement 大话，夸大的叙述
 - clog n.障碍，木底鞋；v.阻塞，阻碍 
 - steady n.关系固定的情侣，固定支架；adj.稳定的，不变的，沉着的；v.稳定，稳固 
 - mitigate v.减轻，缓和 
 - intensive n.加强器；adj.密集的，加强的，集中的，透彻的 
 - occasionally 偶尔
 - govern v.管理，支配，统治，控制 
 - incur v.招致，遭受，带来 
 - notable n.名人，显要人物；adj.显著的，著名的，值得注意的 
 - burst n.爆炸，冲刺，迸发；v.爆炸，爆裂，戳破，装满，充满感情，冲开，分页 
 - smooth n.平滑部分；adj.顺利的，光滑的，平稳的；v.光滑，缓和，平静，消除（障碍等），使优雅 
 - progressively 渐进地；日益增多地 
 - retransmit 转播；中继；重新发送 
 - queue up 排队等候
 - saturation 饱和，饱和度，浸透 
 - puzzle v.迷惑，（因迷惑）而苦思，使..为难；n.谜，智力游戏，拼图 
 - insanity n.疯狂，精神错乱，精神病 
 - instant n.瞬间，立即，片刻；adj.立即的，紧急的 
 - solitaire n.单人跳棋，单人纸牌游戏，独立宝石首饰 
 - unsanitary 不卫生的；有碍健康的 
 - dine v.宴请，用餐
 - philosopher 哲学家 
 - chopstick 筷子
 - diner 用餐者；路边小饭店 
 - embrace n.拥抱；v.拥抱，信奉，皈依，包含，围绕 
 - intervention n.干预，介入 
 - manifest n.载货单，旅客名单；v.表明，显示；adj.显然的，明显的；adv.明显地  
 - inspect v.检查；视察；检阅 
 - fund n.基金，资金，存款；v.投资，资助 
 - debit v.借记，借方，（从银行账户中）取款；n.借记，借方
 - credit n.信用，信誉，贷款，学分，信任，声望；v.相信，归功于，赞颂  
 - spot n.地点，斑点；v.认出，弄脏，用灯光照射；adv.准确地，恰好 

Writing thread-safe code is about managing access to **shared, mutable** state.


> java synchronization：

 - synchronized keywords： provide exclusive locking 
 - volatile variables
 - Explicit Lock
 - atomic variables

> if multiple threads access the same mutable state variable without appropriate synchronization, your program is broken. There are three ways to fix it: 

  - Don't share the state variable across thread;
  - Make the state variable immutable
  - Use synchronization whenever accessing the state variable
  

> Practice:

  It is always a good practice first to make your code right, and then make it fast. Even then, pursue optimization only if you performance measurements and requirements tell you that you must, and if those some measurements tell you that your optimization actually made a difference under realistic conditions.

a program that consists entirely of thread-safe class may not be thread-safe, and a thread-safe classes may contain classes that are not thread-safe.


> Thread-safe class:

 A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordinationon the part of the calling code. <br />

 No set of operations performed sequentially or concurrently on instances of a thread-safe class can cause an instance to be in an invalid state. <br />

 Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.

 Stateless objects are always thread-safe.

> Race Conditions

  A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime; in other words, when gettig the right answer relieson lucky timing. <br />

  The most common type of race condition is check-then-act, where a potentially stale observation is used to make a descision on what to do next.<br />

  To ensure thread safety, check-then-act operations (like lazy initialization) and read-modify-write operations (like increment) must always be atomic.

( **data race: arises when synchronization is not used to coordinate all access to a shared non-final field. Not all race conditions are data races, and not all data races are race conditions, but they both can cause concurrent programs to fail in unpredictable ways.** )

> synchronized:

``` java
  synchronized (lock) {
    // body 
  }
```
synchronized block has two parts:

 - a reference to an object that will serve as the lock (Synchronized method's lock is the object on which the mehtod is being invoked. Static synchronized methods use the Class object for the lock.)
 - a block of code to be guarded by that lock (synchronized method spans an entire method body)

> Intrinsic locks 

  Every Java object can implicitly act as a lock for purposes of synchronization; these built-in locks are called intrinsic locks or monitor locks. The lock is automatically acquired by the executing thread before entering a synchronized block and automatically released when control exits the synchronized block, whether by the normal control path or by throwing an exception out of the block.The only way to acquire an intrinsic lock is to enter a synchronized blcok or method guarded by that lock. <br />

  Intrinsic locks in Java act as mutexes (or mutual exclusion locks), which means that at most one thread may own the lock.<br />

  Intrinsic locks are reentrant, if a thread tries to acqire a lock that it already holds, the request succeeds.

> Serialized access:

  Serialized acess to an object has nothing to do with object serialization; serialized access means that threads take turns accessing the object exclusively, rather than doing so concurrently.

Every shared, mutable variable should be guarded by exactly **one lock**.

There is frequently a tension between simplicity and performance.When implementing a synchronization policy, resist the temptation to prematurely sacrifice simplicity (potentially compromising safety) for the sake of performance.

Avoid holding locks during lengthy computations or operations at risk of not completing quickly such as network or console IO.

> Memory Visibility 

In order to ensure visibility of memory writes across threads, you must use synchronization.

> Reordering

There is no guarantee that operations in one thread will be performed in the order given by the program, as long as the reordering is not detectable from within that thread - even if the reordering is apparent to other threads.

> The Java Memory Model requires fetch and store operations to be atomic, bur for nonvolatile long and double variables, the JVM is permitted to treat a 64-bit read or write as two separate 32-bit operations.If the reads and writes occur in different threads, it is therefore possible to read a nonvolatile long and get back the high 32 bits of one value and the low 32 bits of another.

> Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all thread see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lcok.

> Volatile Variables 

When a field is declared volatile, the compiler and runtime are put on notice that this variable is shared and that operations on it should not be reordered with other memory operations.Volatile variables are not cached in registers or in caches where they are hidden from other processors, so a read of a volatile variable always returns the most recent write by any thread.<br />

Yet accessing a volatile variable perfroms no locing and so cannot cause the executing thread to block, making volatile variables a lighter-weight synchronization mechanism than synchronized. (Volatile reads are only slightly more expensive than nonvolatile reads on most current processor architectures.) <br />

Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when verifying correctness would require subtle reasoning about visibility. Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event(such as initialization or shutdown) has occurred. <br />

Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.<br />

You can use volatile variables only when all the following criteria are met:

- Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;
- The variable does not participate in invariants with other state variables;
- Locing is not required for any other reason while the variable is being accessed.

> Publication and Escape

Publishing an object means making it available to code outside of its current scope, such as by storing a reference to it where other code can find it, returning it from a non-private method, or passing it to a method in another class.<br />

An object that is published when it should not have been is said to have escaped.<br />

An object is in a predictable, consistent state only after its constructor returns, so publishing an object from within its constructor can publish an imcompletely constructed object. This is true even if the publication is the last statement in the constructor. If the this reference escapes during construction, the object is considered not properly constructed.<br />

When an object create a therad from its constructor, it almost always shares its this reference with the new thread, either explicitly (by passing it to the constructor) or implicitly (because the Thread or Runnable is an inner class of the owing object). The new Thread might then be able to see the owning object before it is fully constructed. There is noting wrong with creating a thread in a consturctor, but it is best not to start the thread immediately. Instead, expose a start or initialize method that starts the owned thread.Calling an overrideable instance method (one that is neither private nor final) from the constructor can also allow the this reference to escape.

> Thread Confinement

If data is only accessed from a single thread, no synchronization is needed.When an object is confined to a thread, such usage is automatically thread-safe even if the confined object itself is not.This technique, thread confinement, is one of the simplest ways to achieve thread safety.<br />

- Ad-hoc Thread Confinement: Ad-hoc thread confinement describes when the responsibility for maintaining thread confinement falls entirely on the implementation.Ad-hoc thread confinement can be fragile because none of the language features, it should be used sparingly.
- Stack Confinement: An object can only be reached through local variables.Maintaining stack confinement for object references requires a little more assistance from the programmer to ensure that the referent does not escape.
- ThreadLocal: Allows you to associate a per-thread value with a value-holding object. The thread-specific values are stored in the Thread object itself, when the thread terminates, the thread-specific values can be garbage collected.

``` java
 private static ThreadLocal<Connection> connectionHolder =
   new ThreadLocal<Connection>(){
       public Connection initialValue(){ 
       // when a thread calls ThreadLocal.get for the first time, initialValue is consulted to provide the initial value for that thread.
           return DriverManager.getConnection(DB_URL);
       }
   };

 public static Connection getConnection() {
    return connectionHolder.get();
 }
```

> Immutability 

An immutable object is one whose state cannot be changed after construction. Immutable objects are inherently thread-safe; their invariants are established by the consturctor, and if their state cannot be changed, these invariants always hold.

An object is immutable if: 

- Its state cannot be modified after construction
- All its field are final (It is technically possible to have an immutable object without all fields being final. java.lang.String lazily computes the hash code the first time hashCode is called and caches it in a non-fianl field, but this work only because that field can take on only one non-default value that is the same every time it is computed because it is derived deterministically from immutable state.)
- It is properly constructed (the this reference does not escape during construction)

 ```java
 public int hashCode() { 
 // hash的计算推迟到第一次调用hashCode(),基于final域value,每次计算结果都相同
   int h = hash; 
   if (h == 0 && value.length > 0) {
     char val[] = value;
     for (int i = 0; i < value.length; i++) {
       h = 31 * h + val[i];
     }
     hash = h;
   }
   return h;
 }
 ```

> Final Fields

Final fields cannot be modified (although the objects they refer to can be modified if they are mutable), but they also have special semantics under the Java Memory Model. It is the use of final fields that makes possible the guarantee of initialization safety that lets immutable objects be freely accesssed and shared without synchronization.<br />

Just as it is a good practice to make all fields private unless they need greater visibility, it is a good practice to make all fields final unless they need to be mutable.

> safe publication

``` java
// unsafe publication
public Holder holder;

pubic void initialize() {
    holder = new Holder(42);
}
```

Two things can go wrong with improperly published objects.Other threads could see a stale value for the Holder field, and thus see a null reference or other older value even though a value has been placed in Holder (While it may seem that field values set in a constructor are the first values written to those fileds and therefore that there no "older" values to see stale value, the Object constructor first writes the default values to all fields before subclass construcotrs run. It is therefore possible to see the default value for a field stale value.).

> Immutable Objects and Initialization Safety

Because immutable objects are so important, the java Memory Model offers a special guarantee of initialization safety for sharing immutable object. An object reference becomes visible to another thread does not necessarily mean that the state of that object is visible to the consuming thread. In order to guarantee a consistent view of the object's state, synchronization is needed.<br />

Immutable objects can be safely accessed even when synchronization is not used to publish the object reference. For this guarantee of initialization safety to hold, all of the requirements for immutability must be met: unmodifiable state, all fields are final, and proper construction. <br />

Immutable objects can be used safely by any thread without additional synchronization, even when synchronization is not used to publish them.<br />

This guarantee extends to the values of all final fields of properly constructed objects; final fields can be safely accessed without additional synchronization. However, if final fields refer to mutable objects, synchronization is still required to access the state of the objects they refer to.

> Safe Publication Idioms

To publish an object safely, both the reference to the object and the object's state must be made visible to other threads at the same time. A properly constructed object can be safely published by:

- Initializing an object reference from static initializer;
- Storing a reference to it into a volatile field or AtomicReference;
- Storing a reference to it into a final field of a properly constructed object
- Storing a reference to it into a field that is properly guarded by a lock

> Effectively Immutable Objects

Objects that are not technically immutable, but whose state will not modified after publication, are called effectively immutable.<br />

Safely published effectively immutable objects can be used safely by any thread without additional synchronization.

> Mutable Objects

To share mutable objects safely, they must be safely published and be either thread-safe or guarded by a lock. <br />

The publication requirements for an object depend on its mutability:

- Immutable objects can be published through any mechanism
- Effectively immutable objects must be safely published
- Mutable objects must be safely published, and must be either thread-safe or guarded by a lock.

> Sharing Objects Safely 

The most useful policies for using and sharing objects in a conucrrent program are: 

- Thread-confined. A thread-confined object is owned exclusively by and confined to one thread, and can be modified by its owning thread.
- Shared read-only. A shared read-only object can be accessed concurrently by multiple threads without additional synchronization, but cannot be modified by any thread. Shared read-only objects include immutable and effectively immutable objects.
- Shared thread-safe. A thread-safe object performs synchronization internally, so multiple threads can freely access it through its public interface without further synchronization.
- Guarded. A guarded object can be accessed only with a specific lock held. Guarded objects include those that are encapsulated within other thread-safe objects and pubished objects that are known to be guarded by a specific lock.


> Instance Confinement 

If an object is not thread-safe, several techniques can still let it be used safely in a multithreaded program. You can ensure that it is only accessed from a single thread (thread confinement), or that all access to it is properly guarded by a lock.<br />

Encapsulating data within an object confines access to the data to the object's methods, make it easier to ensure that the data is always accessed with the appropriate lock held.<br />

Confined objects must not escape their intended scope. An object may be confined to a class instance (such as a private class member), a lexical scope (such as a local variable), or a thread (such as an object that is passed from method to method within a thread, but not supposed to be shared across threads.)

> The Java Monitor Pattern

```java
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;

    void someMethod() {
        synchronized (myLock) {
            // access or modify the state of widget
        }
    }
}
```

Making the lock object private encapsulates the lock so that client code cannot acquire it, whereas a publicly accessible lock allows client code to participate in its synchronization policy - correctly or incorrectly.


``` java
@NotThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    // it synchronizes on wrong lock, use different locks
    public synchronized boolean putIfAbsent (E x) {
        boolean absent = !list.contains(x);
        if (absent) {
            list.add(x);
        }
        return absent;
    }
} 
```

```java 
@ThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public boolean putIfAbsent (E x) {
        synchronized (list) {
          boolean absent = !list.contains(x);
          if (absent) {
              list.add(x);
          }
          return absent;
        }
    }
}
```

```java
@ThreadSafe
public class ImporvedList<T> implements List<T> {
    private final List<T> list;

    public ImporvedList(List<T> list) { this.list = list; }

    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (!contains) {
            list.add(x);
        }
        return !contains;
    }

    public synchronized void clear() {
        list.clear();
    }
}
```

> Synchronized Collections: Vector, Hashtable, synchronized wrapper class created by the Collections.synchronizedXXX factory methods. These classes achieve thread safety by encapsulating their state and synchronizing every public method so that only one thread at a time can access the collection state. 

Synchronized Collections achieve their thread safety by serializing all access to the collection's state. The cost of this approach is poor concurrency; when multiple threads contend for the collection-wide lock, throughput suffers.


> Iterator and ConcurrentModificationException 

fail-fast: if they detect that the collection has changed since iteration began, they throw the unchecked ConcurrentModificationException. They are implemented by associating a modification count with the collection: if the modification count changes during iteration, hasNext() or next() throws ConcurrentModificationException.However, this check is done without synchronization, so there is a risk of seeing a stale value of the modification count and therefore that the iterator does not realize a modification has been made. This was a deliberate design tradeoff to reduce the performance impact of the concurrent modification detection code.<br />

(**在单线程代码中也可能抛出ConcurrentModificationException异常，当对象直接从容器中删除而不是通过Iterator.remove()来删除时就会抛出该异常。<remove()方法会修改exceptedModCount的值>**) <br />

The way to prevent ConcurrentModificationException:

- hold the collection lock for the duration of the iteration
- clone the collection and iterate the copy instead (The collection still must be locked during the clone operation itself.)<br />

Iteration is indirectly invoked by the collection's hashcode, equals and toString methods, which may be called if the collection is used as an element of key of another collection. Similarly, the containsAll, removeAll, and retainAll methods, as well as the constructors that take collections are arguments, also iterate the collection. All of these indirect uses of iteration can cause ConcurrentModificationException.

> Concurrent Collections: 

- ConcurrentHashMap: a replacement for synchronized hash-based Map implementation. 
  
   ConcurrentHashMap, along with the other concurrent collections, further improve on the synchronized collection classes by providing iterators that do not throw ConcurrentModificationException, thus eliminating the need to lock the collection during iteration. The iterators returned by ConcurrentHashMap are weakly consistent instead of fail-fast. <br />

   A weakly consistent iteartor can tolerate concurrent modification, traverses elements as they existed when the iterator was constructed, and may (but is not guarantee to) reflect modifications to the collection after the construction of the iterator.<br />



    jdk 7 : segment 实现，对整个Map进行计算的方法语义进行弱化，如size返回的结果可能已经过期，实际上只是个估计值；<br /> 
    jdk 8 : CAS，synchronized 实现<br />

    [为并发而生的 ConcurrentHashMap（Java 8）](https://www.jianshu.com/p/e99e3fcface4)<br />
    [为什么ConcurrentHashMap的读操作不需要加锁？](https://juejin.im/entry/5b98b89bf265da0abd35034c)

- ConcurrentSkipListMap: a replacement for a synchronized SortedMap

- ConcurrentSkipListSet: a replacement for a synchronized SortedSet

- CopyOnWriteArrayList: a replacement for synchronized List implementations for cases where traversal is the dominant operation.
    
    They implement mutability by creating and republishing a new copy of the collection every time it is modified. Iterators for the copy-on-write collections retain a reference to the backing array that was current at the start of iteration, and since this will never change, they need to synchronize only brieflyto ensure visibility of the array contents. The iteartors returned by the copy-on-write collections do not throw ConcurrentModificationException and return the elements exactly as they were at the time the iterator was created, regardless of subsequent modifications.<br />

    The copy-on-write collections are reasonable to use only when iteration is far more common than modification.

- ConcurrentMap： new interface, adds support for common compound actions such as put-if-absent, replace, and conditional remove.<br />

- Queue: is intended to hold a set of elements temporarily while they await processing. Queue operations do not block; if the queue is empty, the retrieval operation returns null.

- ConcurrentLinkedQueue: a traditional FIFO queue

- PriorityQueue: a (non concurrent) priority ordered queue

- BlockingQueue: extends Queue to add blocking insertion and retrieval operations. If the queue is empty, a retrieval blocks until an element is available, and if the queue is full (for bounded queues) an insertion blcoks until there is space available. Blocking queues are extremely useful in producer-consumer design.

- BlockingQueue and producer-consumer

```java
/* Inserts the specified element into this queue, waiting if necessary for space to become available. */
    void put(E e) throws InterruptedException;
    
/* Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. */    
    E take() throws InterruptedException;
```

| Implements | Detail |
| - | - |
| ArrayBlockingQueue | FIFO，有界 |
| LinkedBlockingQueue | FIFO，有界或无界 |
| PriorityBlockingQueue | 有界，process elements in priority-ordered other than FIFO, can compare elements according to their natural order (if they implement Comparable) or using Comparator. |
| SynchronousQueue | in that it maintains no storage space for queued element. Instead, it maintains a list of queued threads waiting to enqueue or dequeue an element. SynchronousQueue has no storage capacity, put and take will block unless another thread is already waiting to partcipate in the handoff. Synchronous queues are generally suitable only when there are enough consumers that there nearly always will be one ready to take the handoff. Executors.newCachedThreadPool() use this queue. |

队列可以是有界的，也可以是无界的，无界队列永远不会充满，因此无界队列上的 put 永远不会阻塞(通常这种无界不是真的无界，而是容量是Integer.MAX_VALUE)。
<br />
[解读 Java 并发队列 BlockingQueue](https://javadoop.com/2017/08/22/java-concurrent-queue/?)

**在构建高可用的应用程序时，有界队列是一种强大的资源管理工具，它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。**

- Deque (pronounced "deck") and BlockingDeque: extend Queue and BlockingQueue.

A Deque is a double-ended queue that allows efficient insertion and removal from both the head and the tail. Implementations include ArrayDeque and LinkedBlockingDeque. <br />

Work Stealing: A producer-consumer design has one shared work queue for all consumers; in a word stealing design, every consumer has its own deque. If a consumer exhausts the work in its own deque, it can steal work from the tail of someone else's deque. Work stealing can be more scalable than a traditional producer-consumer design because workers don't contend for a shared work queue; most of the time they access only their own deque, reducing contention. When a worker has to access another's queue, it does so from the tail rather than the head, further reducing contention. <br />

Work stealing is well suited to problems in which consumers are also producers - when performing a unit of work is likely to result in the identification of more work.

> Blocking and Interruptible Methods 

Threads may block or pause for serveral reasons: 

- waiting for I/O completion 
- waiting to acquire a lock
- waiting to wake up from Thread.sleep
- waiting for the result of a computation in another thread

When a thread blocks, it is usually suspended and palced in one of the blocked thread states (BLOCKED, WAITING, or TIMED_WAITING). <br />

The distinction between a blocking operation and an ordinary opeartion that merely takes a long time to finish is that a blocked thread must wait for an event that is beyond its control before it can proceed - the I/O completes, the lock becomes available, or the external computation finishes. When that external event occurs, the thread is placed back in the RUNNABLE state and becomes eligible again fro scheduling.<br />

When a method can throw InterruptedException, it is telling you that it is a blocking method, and further that if it is interrupted, it will make an effort to stop blocking early. Thread provides the interrupt method for interrupting a thread and for querying whether a thread has been interrupted. Each thread has a boolean property that represents its interrupted status; interrupting a thread sets this status.<br />

Interruption is a cooperative mechanism. One thread cannot force another to stop what it is doing and do something else; when thread A interrupts thread B, A is merely requesting that B stop what it is doing when it gets to a convenient stopping point - if it feels like it.<br />

When your code calls a method that throws InterruptedException, then your method is a blocking method too, and must have a plan for responding to interruption. For library code, there are basically two choices:

- Propagate the InterruptedException. just propagate the InterruptedException or catching it and throwing it again after performing some brief activity-specific cleanup.
- Restore the interrupt. catch InterruptedException and restore the interrupted status by calling interrupt on the current thread.

线程状态转换：
![](https://github.com/CyC2018/CS-Notes/blob/master/pics/ace830df-9919-48ca-91b5-60b193f593d2.png)


> Synchronizers: A synchronizer is any object that coordinates the control flow of threads based on its state; like blocking queues, semaphores, barriers, latches.

All synchronizers share certain structual properties: they encapsulate state that determines whether threads arriving at the synchronizer should be allowed to pass or forced to wait, provide methods to manipulate that state, and provide methods to wait efficiently for the synchronizer to enter the desired state.<br />

> Latches: A latch is a synchronizer that can delay the progress of threads until it reaches its terminal state. A latch acts as gate: until the latch reaches the terminal state the gate is closed and no thread can pass, and in the terminal state the gate opens, allowing all thread to pass. Once the latch reaches the terminal state, it cannot change state again, so it remains open forever.

Latches can be used to ensure that certain activities do not proceed until other one-time activities complete, such as:

- Ensuring that a computation does not proceed until resoures it needs have been initialized.
- Ensuring that a service does not start until other services on which it depends have started.
- Waiting until all the parties involved in an activity.

CountDownLatch: is a flexible latch implementation that can be used in any of these situations; it allows one or more threads to wait for a set of events to occur.

```java
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {}
                }
            }
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

> FutureTask: acts like a latch. (FutureTask implements Future, which descibes an abstract result-bearing computation.) A computation represented by a FutureTask is implemented with a Callable, the result-bearing equivalent of Runnable, and can be in one of three states: waiting to run, running or completed. Completion subsumes all the ways a computation can complete, including normal completion, cancellation, and exception. Once a FutureTask enters the completed state, it stays in the state forever.

The behavior of Future.get depends on the state of the task. If it is completed, get returns the result immediately, and otherwise blocks until the task transitions to the completed state and then returns the result or throws an exception. FutureTask conveys the result from the thread executing the computation to the thread retrieving the result; the specification of FutureTask guarantees that this transfer constitutes a safe publication of the result.

``` java
public class Preloader {
    private final FutureTask<ProductInfo> future = new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
          public ProductInfo call() throws DataLoadException {
            return loadProductInfo();
          }
    });

    private final Thread thread = new Thread(future);

    pubilc void start() {
        // it is inadvisable to start a thread from a constructor or static initializer 
        thread.start(); 
    }

    public ProductInfo get() 
        throws DataLoadException, InterruptedException {
            try {
                // whatever the task code may throw, it is wrapped in an ExecutionException and rethrown from Future.get
                return future.get();
            } catch (ExecutionException e) {
                Throable cause = e.getCause();
                if (cause instanceof DataLoadException) {
                    throw (DataLoadException) cause;
                } else {
                    throw launderThrowable(cause);
                }
            }
    }
}
```

Treiber stack : FutureTask中使用到了这种无锁并发栈,用来保存等待的线程，其实现方式是 CAS + 重试 <br />
[FutureTask源码解读](http://www.cnblogs.com/micrari/p/7374513.html)

> Semaphores: Counting semaphores are used to control the number of activities that can access a certain resource or perform a given action at the same time.Counting semaphores can be used to implement resource pools or to impose a bound on a collection.

A Semaphore manages a set of virtual permits; the initial number of permits is passed to the Semaphore consturctor. Activities can acquire permit (as long as some remain) and release permits when they are done with them. If no permit is available, acquire blocks until one is (or until interrupted or the operation times out). The release method returns a permit to the Semaphore.

```java
public class BoundedHashSet<T> {
    private final Set<T> set;
    private final Semaphore sem; 

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false; 
        try {
            wasAdded = set.add(o);
            return wasAdded;
        } finally {
            if (!wasAdded) {
                sem.release();
            }
        }
    }

    public boolean remove(Object o) {
        boolena wasRemoved = set.remove(o);
        if (wasRemoved) {
            sem.release();
        }
        return wasRemoved;
    }
} 
```

> Barriers: Latches are single-use objects; once a latch enters the terminal state, it cannot be reset. Barriers are similar to latches in that they block a group of threads until som event has occurred. The key difference is that with a barrier, all the threads must come together at a barrier point at the same time in order to proceed. Latches are for waiting for events; barriers are for waiting for other threads.

CyclicBarrier allows a fixed number of parties to rendezvous repeatedly at a barrier point and is useful in parallel iterative algorithms that break down a problem into a fixed number of independent subproblems. Thread call await when theye reach the barrier point, and await blocks until all the threads have reached the barrier point. If alll threads meet at the barrier point, the barrier has been successfully passed, in which case all threads are released and the barrier is reset so it can be used again. If a call to await times out or a thread blocked in await is interrupted, then the barrier is considered broken and all outstanding calls to await terminate with BrokenBarrierException.

 ```java
  public CyclicBarrier(int parties);

  /**
   * execute the given barrier action when the barrier is tripped,
   * performed by the last thread entering the barrier.
   */
  public CyclicBarrier(int parties, Runnable barrierAction);
  /**
   * Waits until all parties have invoked await on this barrier.
   * @return the arrival index of the current thread, where index
   *         {@code getParties() - 1} indicates the first
   *         to arrive and zero indicates the last to arrive
   */
  public int await() throws InterruptedException, BrokenBarrierException；
 ```

 ``` java
 public class CellularAutomata {
    private final Board mainBoard;
    private final CyclicBarrier barrier; 
    private final Worker[] workers;  

    public CellularAutomata(Board board) {
        this.mainBoard = board;
        int count = Runtime.getRuntime().availableProcessors();
        this.barrier = new CyclicBarrier(count, new Runnable() {
            public void run() {
                mainBoard.commitNewValues();
            }
        });
        this.worker = new Worker[count];
        for (int i = 0; i < count; i++) {
            worker[i] = new Worker(mainBoard.getSubBoard(count, i));
        }
    }

    private class Worker implements Runnable {
    private final Board board;

    public Worker(Board board) {
        this.board = board;
    }

    public void run() {
        while (!board.hasConverged()) {
            for (int x = 0; i < boardMaxX(); x++) {
                for (int y = 0; y < board.getMaxY(); y++) {
                    board.setNewValue(x, y, computeValue(x, y));
                }
            }
            try {
                barrier.await();
            } catch (InterruptedException ex) {
                return;
            } catch (BrokenBarrierException ex) {
                return;
            }
        }
    }
 }

 public void start() {
    for (int i = 0; i < workers.length; i++) {
        new Thread(workers[i]).start();
    }
    mainBoard.waitForConvergence();
 } 
}
 ```

Another form of barrier is Exchanger, a two-party barrier in which the parties exchange data at the barrier point.<br />

[Exchanger](!https://www.cnblogs.com/12344321hh/p/10637358.html)

```java
//实现一个缓存器
public interface Computable<A, V> {
	V compute(A args) throws InterruptedException;
}

public class Memoizer<A, V> implements Computable<A, V>{
	private final Map<A, FutureTask<V>> cache = 
			new ConcurrentHashMap<>();
	
	private final Computable<A,V> comp;
	
	public Memoizer(Computable<A,V> comp) {
		this.comp = comp;
	}
	
	public V compute(final A args) throws InterruptedException {
		
		while(true) {
			FutureTask<V> f = cache.get(args);
			
			if(f == null) {
				Callable<V> callable = new Callable<V>() {
					@Override
					public V call() throws InterruptedException {
						return comp.compute(args);
					}
				};
				
				FutureTask<V> ft = new FutureTask<>(callable);
				
				f = cache.putIfAbsent(args, ft);
				
				if(f == null) {
					f = ft;
					ft.run();
				}
			}
			
			try {
				return f.get();
			} catch(CancellationException e) {
				cache.remove(args, f);  // Cache Pollution, removed
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
	}
}
```

> Main concepts and rules:

- It's the mutable state, stupid. 
  All concurrency issues boil down to coordinating access to mutable state. The less mutable state, the easier it is to ensure thread safety.
- Make fields final unless they need to be mutable.
- Immutable objects are automatically thread-safe.
  Immutable objects simplify concurrent programming tremendously. They are simpler and safer, and can be shared freely without lokcing or defensive copying.
- Encapsulation makes it practical to manage the complexity.
- Guard each mutable variable with a lock.
- Guard all variables in an invariant with the same lock.
- Hold locks for the duration of compound actions.
- A program that accesses a mutable variable from multiple threads without synchronization is a broken program.
- Don't rely on clever reasoning about why you don't need to synchronize.
- Include thread safety in the design processor explicitly document that your class is not thread-safe.
- Document your synchronization policy.

> Up to a certain point, more threads can improve throughput, but beyond that point creating more threads just slows down your application, and creating one thread too many can cause your entire application to crash horribly.

> The Executor Framework 

The primary abstraction for task execution in the Java class library (java.util.concurrent) is not Thread, but Executor. Executor forms the basis for a flexible and powerful framework for asynchronous task execution that supports a wide variety of task execution policies. It provides a standard means of decoupling task submission from task execution, describing tasks with Runnable. The Executor implementations also provide lifecycle support and hooks for adding statistics gathering, application management, and monitoring.<br />

```java 
public interface Executor {
    void execute(Runnable command);
} 
```

Executor is based on the producer-consumer pattern, where activities that submit tasks are the producers (producing units of work to be done) and the threads that execute tasks are the consumers (consuming those units of work). Using an Executor is usually the easiest path to implementing a producer-consumer design in your application.


> Thread Pools: A thread pool is tightly bound to a work queue holiding tasks waiting to be executed. Worker threads have a simple life: request the next task from the work queue, execute it, and go back to waiting for another task.

You can create a thread pool by calling one of the static factory methods in Executros: (阿里建议使用ThreadPoolExecutor自定义线程池替代Executors的静态方法)

- newFixedThreadPool: adds new thread if threads if a thread dies due to an unexpected Exception.
- newCachedThreadPool: places no bounds on the size of the pool
- newSingleThreadExecutor: replace thread if it dies unexpected.
- newScheduledThreadPool: A fixed-size thread pool that supports delayed and periodic taks execution.


> Executor Lifecycle

To address the issue of execution service lifecycle, the ExecutorService interface extends Executor, adding a number of methods for lifecycle management (as well as some convenience methods for task submission). <br />

The lifecycle implied by ExecutorService has three states - running, shutting down, and terminated.

```java
public interface ExecutorService extends Executor {

    /**
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * <p>This method does not wait for previously submitted tasks to
     * complete execution.  Use {@link #awaitTermination awaitTermination}
     * to do that.
     */
    void shutdown(); // initiates a graceful shutdown: no new tasks are accepted but perviously submitted tasks are allowed to complete - including those that have not yet begun execution.

    /**
     * @return list of tasks that never commenced execution
     */
    List<Runnable> shutdownNow(); // initiates an abrupt: it attempts to cancel outstanding tasks and does not start any tasks that are queued but not begun.
    boolean isShutdown();
    boolean isTerminated();
    Future<?> submit(Runnable task);
    <T> Future<T> submit(Runnable task, T result);
    <T> Future<T> submit(Callable<T> task);
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
}
```

> Delayed and Periodic Tasks 

Timer does have support for scheduling based on absolute, not relative time, so that tasks can be sensitive to changes in the system clock; ScheduledThreadPoolExecutor supports only relative time. <br />

A Timer creates only a single thread for executing timer tasks. If a timer task takes too long to run, the timing accuracy of other TimerTasks can suffer. If a recurring TimerTask is scheduled to run every 10 ms and another TimerTask takes 40 ms to run, the recurring task either (depending on whether it was scheduled at fixed rate or fixed delay) gets called four times in rapid sucession after the long-running task completes, or "misses" four invocations completely. Scheduled thread pools address this limitation by letting you provide multiple thread for executing deferred and periodic tasks.<br />

Timer behaves poorly if a TimerTask throws an unchecked exception. The Timer thread doesn't catch the exception, so an unchecked exception thrown from a TimerTask terminates the timer thread. Timer also doesn't resurrect the thread in this situation.

> Result-bearing Tasks: Callable and Future 

The Executor framework uses Runnable as its basic task representation.

```java
public interface Runnable {
    // cannot return a value or throw checked excepitons
    public abstract void run();  
}

public interface Callable<V> {
    V call() throws Exception;
}

```

Future represents the lifecycle of a task and provides methods to test whether the task has completed or been cancelled, retrieve its result, and cancel the task. Future is that task lifecycle can only move forwards, not backwards - just like the ExecutorService lifecycle. Once a task is completed, it stays in that state forever.<br />

The behavior of get varies depending on the task state (not yet started, running, completed). It returns immediately or throws an Exception if the task has already completed, but if not it blocks until the task completes. If the task completes by throwing an exception, get rethrows it wrapped in an ExecutionException; if it was cancelled, get throws CancellationException.

```java

public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);
	boolean isCancelled();
	boolean isDone();
	V get() throws InterruptedException, ExecutionException;
	V get(long timeout, TimeUnit unit)
       	 throws InterruptedException, ExecutionException, TimeoutException;
}

```

There are several ways to create a Future to describe a task. The submit methods in ExecutorService all return a Future, so that you can submit a Runnable or a Callable to an executor and get back a Future that can be used to retrieve the result or cancel the task. You can also explicitly instantiate a FutureTask for a given Runnable or Callable (FutureTask implements Runnable).
As of Java 6, ExecutorService implementations can override newTaskFor in AbstractExecutorService to control instantiation of the Future corresponding to a submitted Callable or Runnable.


> CompletionService

CompletionService combines the functionality of an Executor and BlockingQueue. You can submit Callable tasks to it for execution and use the queue-like methods take and poll to retrieve completed results, packaged as Futrues, as they become available. ExecutorCompletionService implements CompletionService, delegating the computation to an Executor. 


> Cancellation and Shutdown

Getting tasks and threads to stop safely, quickly, and reliably is not always easy. Java does not provide any mechanism for safely forcing a thread to stop what it is doing (The deprecated Thread.stop and suspend methods were an attempt to provide such a mechanism, but were quickly realized to be seriously flawed and should be avoided.). Instead, it provides interruption, a cooperative mechanism that lets one thread ask another to stop what it is doing.

> Task Cancellation 

There is no safe way to preemptively stop a thread in Java, and therefore no safe way to preemptively stop a task. There are only cooperative mechanisms, by which the task and the code requesting cancellation follow an agreed-upon protocol.<br />

One such cooperative mechanism is setting a "cancellation requested" flag that the task checks periodically; if it finds the flag set, the task terminates early. <br />

There is nothing in the API or language specification that ties interruption to any specific cancellation semantics, but in practice, using interruption for anything but cancellation is fragile and difficult to sustain in larger applications. <br />

Each thread has a boolean interrupted status; interrupting a thread sets its interrupted status to true. Thread contains methods for interrupting a thread and querying the interrupted status of a thread.<br />

```java
public class Thread {
    // interrupt the target thread
    public void interrupt() { ... }
    // return the interrupted status of the target thread
    public boolean isInterrupted() { ... }
    // clear the interrupted status of the current thread and return its previous value; this is the only way to clear the interrupted status.
    public static boolean interrupted() { ... }
} 
```

Blocking library methods like Thread.sleep and Object.wait try to detect when a thread has been interrupted and return early. They respond to interruption by clearing the interrupted status and throwing InterruptedException, indicating that the blocking opeartion completed early due to interruption. The JVM makes no guarantees on how quickly a blocking method will detect interruption, but in practice this happens reasonably quickly. <br />

Calling interrupt does not necessarily stop the target thread from doing what it is doing; it merely delivers the message that interruption has been requested. **Interruption is usually the most sensible way to implement cancellation.** <br />

Because each thread has its own interruption policy, you should not interrupt a thread unless you know what interruption means to that thread.<br />

When you call an interruptible blocking method such as Thread.sleep or BlockingQueue.put, there are two practical strategies for handling InterruptedException:

- Propagete the exception (possibly after some task-specific cleanup), making your method an interruptible blocking method, too
- Restore the interruption status so that code higher up on the call stack can deal with it. The standard way to do this is to restore the interrupted status by calling interrupt again. What you should not do is swallow the InterruptedException by catching it and doing nothing in the catch block, unless your code is actually implementing the interruption policy for a thread.

> Cancellation Via Future 

```java
public interface Future<V> {
    /**
     * Attempts to cancel execution of this task.  This attempt will
     * fail if the task has already completed, has already been cancelled,
     * or could not be cancelled for some other reason. If successful,
     * and this task has not started when {@code cancel} is called,
     * this task should never run.  If the task has already started,
     * then the {@code mayInterruptIfRunning} parameter determines
     * whether the thread executing this task should be interrupted in
     * an attempt to stop the task.
     */
    boolean cancel(boolean mayInterruptIfRunning);
}
```

When Future.get throws InterruptedException or TimeoutException and you know that the result is no longer needed by the program, cancel the task with Future.cancel.

> Dealing with Non-interruptible Blocking 

Not all blocking methods or blcoking mechanisms are responsive to interruption; if a thread is blocked performing synchronous socket I/O or waiting to acquire an intrinsic lock, interruption has no effect other than setting the thread's interrupted status.<br />

Synchronous socket I/O in java.io. The common form of blocking I/O in server applications is reading or writing to a socket. Unfortunately, the read and write methods in InputStream and OutputStream are not responsive to interruption, but closing the underlying socket makes any threads blocked in read or write throw a SocketException.<br />

Synchronous I/O in java.nio. Interrupting a thread waiting on an InterruptibleChannel causes it to throw ClosedByInterruptException and close the channel (and also causes all other threads blocked on the channel to throw ClosedByInterruptException). Closing an InterruptibleChannel causes threads blocked on the channel operations to throw AsynchronousCloseException. Most standard Channels implement InterruptibleChannel.<br />

Asynchronous I/O with Selector. If a thread is blocked in Selector.select (in java.nio.channels), wakeup causes it to return prematurely by throwing a ClosedSelectorException.<br />

Lock acquisition. If a thread is blocked waiting for an intrinsic lock, there is nothing you can do to stop it short of ensuring that it eventually acquires the lock and makes enough progress that you can get its attention some other way. However, the explicit Lock classes offer the lockInterruptibly method, which allows you to wait for a lock and still be responsive to interrupts.

> Stopping a Thread-based Service

Sensible encapsulation practices dictate that you should not manipultate a thread - interrupt it, modify its priority, etc. - unless you own it. The thread API has no formal concept of thread ownership: a thread is represented with a Thread object that can be freely shared like any other object. However, it makes sense to think of a thread as having an owner, and this is usually the class that created the thread. So a thread pool owns its worker threads, and if those threads need to be interrupted, the thread pool should take care of it.<br />

Provide lifecycle methods whenever a thread-owning service has a lifetime longer than that of the method that created it.<br />

There is no general way to find out which tasks started but did not complete. This means that there is no way of knowing the state of the tasks in progress at shutdown time unless the tasks themselves perform some sort of checkpointing. 

``` java
public class TrackingExecutor extends AbstractExecutorService {
    private final ExecutorService exec;
    private final Ser<Runnable> tasksCancelledAtShutdown = Collections.synchronizedSet(new HashSet<Runnable>());
    ...
    public List<Runnable> getCancelledTasks() {
        if (!exec.isTerminated()) {
            throw new IllegalStateException(...);
        }
        return new ArrayList<Runnable>(tasksCancelledAtShutdown);
    } 

    public void execute(final Runnable runnable) {
        exec.execute(new Runnable() {
            public void run() {
                try {
                    runnable.run();
                } finally {
                    if (isShutdown() && Thread.currentThread().isInterrupted()){
                        tasksCancelledAtShutdown.add(runnable);
                    }
                }
            }
        });
    }
} 
```

> Handling Abnormal Thread Termination

The leading cause of premature thread death is RuntimeException. 

```java
// Typical Thread-pool Worker Thread Structure
public void run() {
    Throwable thrown = null;
    try {
        while (!isInterrupted()) {
            runTask(getTaskFromWorkQueue());
        }
    } catch (Throwable e) {
        thrown = e;
    } finally {
        threadExited(this, thrown);
    }
} 
```

The Thread API provides the UncaughtExceptionHandler facility, which lets you detect when a thread dies due to an uncaught exception. When a thread exits due to an uncaught exception, the JVM reports this event to an application-provided UncaughtExceptionHandler; if no handler exists, the default behavior is to print the stack trace to System.err.<br />

```java
public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
} 
```

Before Java 5.0, the only way to control the UncaughtExceptionHandler was by subclassing ThreadGroup. In Java 5.0 and later, you can set an UncaughtExceptionHandler on a per-thread basis with Thread.setUncaughtExceptionHandler, and can also set the default UncaughtExceptionHandler with Thread.setDefaultUncaughtExceptionHandler. However, only one of these handlers is called first the JVM looks for a per-thread handler, then for a ThreadGroup handler. The default handler implementation in ThreadGroup delegates to its parent thread group, and so on up the chain until one of the ThreadGroup handlers deals with the uncaught exception or it bubbles up to the top-level thread group. The top-level thread group handler delegates to the default system handler (if one exist; the default is none) and otherwise prints the stack trace to the console.

To set an UncaughtExceptionHandler for pool threads, provide a *ThreadFactory* to the *ThreadPoolExecutor* constructor. Somewhat confusingly, exceptions thrown from tasks make it to the uncaught exception handler only for tasks submitted with *execute*; for tasks submitted with *submit*, any thrown exception, checked or not, is considered to be part of the task's return status. If a task submitted with *submit* terminates with an exception, it is rethrown by Future.get, wrapped in an ExecutionException.

> JVM shutdown: The JVM can shut down in either an orderly or abrupt manner. An orderly shutdown is initiated when the last "normal"(non-daemon) terminates, someone calls *System.exit*, or by other platform-specific means (such as sending a SIGINT or hitting Ctrl-C). While this is the standard and preferred way for the JVM to shut down, it can also be shut down abruptly by calling *Runtime.halt* or by killing the JVM process through the operating system (such as sending a SIGKILL).

> shutdown hooks: Shutdown hooks are unstarted threads that are registered with *Runtime.addShutdownHook*. The JVM makes no guarantees on the order in which shutdown hooks are started.

```java
Runtime.getRuntime().addShutdownHook(Thread hook);
```

> Daemon Threads: Sometimes you want to create a thread that performs some helper function but you don't want the existence of this thread to prevent the JVM from shutting down. This is what daemon threads are for.

Threads are divided into two types: normal threads and daemon threads. When the JVM starts up, all the threads it creates (such as garbage collector and other housekeeping threads) are daemon threads, except the main thread. When a new thread is created, it inherits the daemon status of the thread that created it, so by default any threads created by the main thread are also normal threads.<br />

Normal threads and daemon threads differ only in what happens when they exit. When a thread exits, the JVM performs an inventory of running threads, and if the only threads that are left are daemon threads, it initiates an orderly shutdown. When the JVM halts, any remaining daemon threads are abandoned - finally blocks are not executed, stacks are not unwound - the JVM just exits.
<br />

Daemon threads should be used sparingly - few processing activities can be safely abandoned at any time with no cleanup. In particular, it is dangerous to use daemon threads for tasks that might perform any sort of I/O. Daemon threads are best saved for "housekeeping" tasks, such as a background thread that periodically removes expired entries from an in-momory cache.

> Finalizers:  finalize()

The garbage collector does a good job of reclaiming memory resources when they are no longer needed, but some resources, such as file or socket handles, must be explicitly returned to the operating system when no longer needed. <br />

In most cases, the combination of *finally* blocks and explicit *close* methods does a better job of resource management than finalizers; Work hard to avoid writing or using classes with finalizers.

> Applying Thread Pools

ThreadLocal should not be used in pool threads to communicate values between tasks.<br />

Thread pools work best when tasks are homogeneous and independent. Mixing long-running and short-running tasks risks "clogging" the pool unless it is very large; submitting tasks that depend on other tasks risks deadlock unless the pool is unbounded.

> Thread Starvation Deadlock: can occur whenever a pool task initiates an unbounded blocking wait for some resource or condition that can succeed only through the action of another pool task, such as waiting for the return value or side effect of another task, unless you can guarantee that the pool is large enough. 

> Long-running Tasks 

One technique that can mitigate the ill effects of long-running tasks is for tasks to use timed resource waits instead of unbounded waits. Most blocking methods in the platform libraries come in both untimed and timed versions, such as *Thread.join*, *BlockingQueue.put*, *CountDownLatch.await*, and *Selector.select*.

> Sizing Thread Pools 

```java
// determine the number of CPUs
Runtime.getRuntime().availableProcessors();
```

For compute-intensive tasks, an N cpu processor system usually achieves optimum utilization with a thread pool of N cpu + 1 threads. For tasks that also include I/O or other blocking operations, you want a larger pool, since not all of the threads will be schedulable at all times. <br />

Of course, CPU cycles are not the only resource you might want to manage using thread pools. Other resources that can contribute to sizing constraints are memory, file handles, socket handles, and database connections. Calculating pool size constraints for these types of resources is easier: just add up how much of that resource each task requires and divide that into the total quantity available. The result will be an upper bound on the pool size.<br />

When tasks require a pooled resource such as database connections, thread pool size and resource pool size affect each other. If each task requires a connection, the effective size of the thread pool is limited by the connection pool size. Similarly, when the only consumers of connections are pool tasks, the effective size of the connection pool is limited by the thread pool size.


> ThreadPoolExecutor:

The core pool size, maximum pool size, and keep-alive time govern thread creation and teardown. The core size is the targe size; the implementation attempts to maintain the pool at this size even when there are no tasks to execute, and will not create more threads than this unless the work queue is full (When a ThreadPoolExecutor is initially created, the core threads are not started immediately but instead as tasks are submitted, unless you call prestartAllCoreThreads.). The maximum pool size is the upper bound on how many pool threads can be active at once. A thread that has been idle for longer than the keep-alive time becomes a candidate for reaping and can be terminated if the current pool size exceeds the core size.

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler); 
```


There are three basic approaches to task queuing: unbounded queue, bounded queue, and synchronous handoff. The choice of queue interacts with other configuration parameters suc as pool size. <br />

The default for newFixedThreadPool and newSingleThreadExecutor is to use an unbounded LinkedBlockingQueue. Tasks will queue up if all worker threads are busy, but the queue could grow without bound if the tasks keep arriving faster than they can be executed. A more stable resource management strategy is to use a bounded queue, such as an ArrayBlockingQueue or a bounded LinkedBlockingQueue or PriorityQueue. Bounded queues help prevent resource exhaustion but introduce the question of what to do with new tasks when the queue is full. <br />

For very large or unbounded pools, you can also bypass queuing entirely and instead hand off tasks directly from producers to worker threads using a SynchronousQueue. A SynchronousQueue is not really a queue at all, but a mechanism for managing handoffs between threads. In order to put an element on a SynchronousQueue, another thread must already be waiting to accept the handoff. If no thread is waiting but the current pool size is less than the maximum, ThreadPoolExecutor creates a new thread; otherwise the task is rejected according to the saturation policy. SynchronousQueue is a practical choice only if the pool is unbounded or if rejecting excess tasks is acceptable. The newCachedThreadPool factory uses a SynchronousQueue.<br />

Bounding either the thread pool or the work queue is suitable only when tasks are independent. With tasks that depend on other tasks, bounded thread pools or queues can cause thread starvation deadlock; instead, use an unbounded pool configuration like newCachedThreadPool.

> Saturation Policies: When a bounded work queue fills up, the saturation policy comes into play. The saturation policy for a ThreadPoolExecutor can be modified by calling setRejectedExecutionHandler.(The saturation policy is also used when a task is submitted to an Executor that has been shut down.) Several implementations of RejectedExecutionHandler are provided, each implementing a different saturation policy: 

- AbortPolicy: the default policy, abort, causes execute to throw the unchecked RejectedExecutionException; the caller can catch this exception and implement its own overflow handling as it sees fit.
- CallerRunsPolicy: implements a form of throttling that neither discards tasks nor throws an exception, but instead tries to slow down the flow of new tasks by pushing some of work back to the caller. It executes the newly submitted task not in a pool thread, but in the thread that calls *execute*. 
- DiscardPolicy: silently discards the newly submitted task if it cannot be queued for execution.
- DiscardOldestPolicy: discards the task that would otherwise be executed next and tries to resubmit the new task.

```java
//ThreadPoolExecutor通过调用该方法修改饱和策略
public void setRejectedExecutionHandler(RejectedExecutionHandler handler);
```

```java
// RejectedExecutionHandler 接口定义
public interface RejectedExecutionHandler {
	void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

> Thread Factories: Whenever a thread pool needs to create a thread, it does so through a thread factory. 

*ThreadFactory* has a single method, *newThread*, that is called whenever a thread pool needs to create a new thread.

```java  
public interface ThreadFactory {

    /**
     * Constructs a new {@code Thread}.  Implementations may also initialize
     * priority, name, daemon status, {@code ThreadGroup}, etc.
     *
     * @param r a runnable to be executed by new thread instance
     * @return constructed thread, or {@code null} if the request to
     *         create a thread is rejected
     */
    Thread newThread(Runnable r);
}
```

Executors includes a factory method, *unconfigurableExecutorService*, which takes an existing *ExecutorService* and wraps it with one exposing only the methods of *ExecutorService* so it cannot be further configured. Unliked the pooled implementations, *newSingleThreadExecutor* returns an *ExecutorService* wrapped in this manner, rather than a raw *ThreadPoolExecutor*. <br />

If you will be exposing an ExecutorService to code you don't trust not to modify it, you can wrap it with an *unconfigurableExecutorService*.

> Extending ThreadPoolExecutor: ThreadPoolExecutor was designed for extension, providing several "hooks" for subclasses to override *beforeExecute*, *afterExecute*, and *terminated* that can be used to extend the behavior of *ThreadPoolExecutor*.

The *beforeExecute* and *afterExecute* hooks are called in the thread that executes the task, and can be used for adding logging, timing, monitoring, or statistics gathering. The *afterExecute* hook is called whether the task completes by returning normally from run or by throwing an Exception. (If the task completes with an *Error*, *afterExecute* is not called.) If *beforeExecute* throws a RuntimeException, the task is not executed and *afterExecute* is not called. <br />

The *terminated* hook is called when the thread pool completes the shutdown process, after all tasks have finished and all worker threads have shut down. It can be used to release resources allocated by the *Executor* during its lifecycle, perform notification or logging, or finalize statistics gathering.


> Deadlock

Deadlock is illustrated by the classic, if somewhat unsanitary, "dining philosophers" problem. <br />

When a thread holds a lock forever, other threads attempting to acquire that lock will blok forever waiting. When thread A holds lock L and tries to acquire lock M, but at the same time thread B holds M and tries to acqire L, both thread will wait forever. This situation is the simplest case of deadlock, where multiple threads wait forever due to a cyclic locking dependency. <br />

> Lock-ordering Deadlocks

A program will be free of lock-ordering deadlocks if all threads acquire the locks they need in a fixed global order. 

> Dynamic Lock Order Deadlocks

```java
// deadlock-prone. The lock order depends on the order of arguments passed to transferMoney 
public void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException {
    synchronized (fromAccount) {
        synchronized (toAccount) {
            if (fromAccount.getBalance().compareTo(amount) < 0) {
                throw new InsufficientFundsException();
            } else {
                fromAccount.debit(amount);
                toAccount.credit(amount);
            }
        }
    }
} 
```
