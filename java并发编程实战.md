
> java同步机制：
 - synchronized关键字： 提供一种独占的加锁方式
 - volatile 
 - 显示锁 (Explicit Lock)
 - 原子变量

> 如果多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。可以有三种方式修复这个问题：
  - 不在线程间共享该状态变量；
  - 将状态变量修改为不可变的变量；
  - 在访问状态变量时使用同步；
  
> 编写并发代码的原则：

 首先使代码正确运行，然后再提高代码的速度。即使如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能的提升时，才进行优化。
 
> 竞态条件(Race Condition)：多个线程由于不恰当的执行时序而出现不正确的结果

大多数竞态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算。
( **数据竞争：如果在访问共享的非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争。**)

> 通常在简单性和性能之间存在相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性(这可能会破坏安全性)。

> 当执行时间较长的计算或者可能无法快速完成的操作时(例如，网络I/O或控制台I/O),一定不要持有锁。

> 重排序：只要在某个线程中无法检测到重排序的情况(即使在其他线程中可以明显地看到该线程中的重排序)，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

> java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型 的double和long变量，JVM允许将64位的读操作和写操作分解成两个32位的操作。当读取一个非volatile类型的long变量时，如果该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作都必须在同一个锁上同步。

> volatile 变量: 在访问volatile变量时不会执行加锁操作，因此也就不会执行线程阻塞，所以volatile变量是比synchronized关键字更轻量级的同步机制；volatile变量会限制一些重排序操作，volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

volatile变量的正确使用方式： 确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生(例如，初始化或关闭)。
<br />
加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
<br />
当且仅当满足以下条件时，才应该使用volatile变量：
 - 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值；
 - 该变量不会与其他状态变量一起纳入不变性条件中；
 - 在访问变量时不需要加锁；

> 发布(publish)与逸出(escape)： 发布一个对象是指使对象能在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况被称为逸出。
``` java
	public static Set<Secret> knownSecrets;
	
	public void initialize() {
		knownSecrets = new HashSet<Secret>();
	}
```
> 线程封闭： 当访问共享的可变数据时，通常需要同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。

- Ad-hoc 线程封闭： 维护线程封闭性的职责完全由程序实现来承担。(脆弱，少用)
- 栈封闭：只能通过局部变量才能访问对象。java语言的语义确保了基本类型的局部变量始终封闭在线程内；在维持对象引用的栈封闭性时需要额外工作确保被引用的对象不会逸出。
- ThreadLocal类：ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用该技术。(实现上ThreadLocal中存储值的对象ThreadLocalMap保存在相应线程的Thread对象中，当线程终止后，这些值会作为垃圾回收)。
``` java
 private static ThreadLocal<Connection> connectionHolder =
   new ThreadLocal<Connection>(){
       public Connection initialValue(){ // 某个线程初次调用ThreadLocal.get(),就会调用获取初始值
           return DriverManager.getConnection(DB_URL);
       }
   };
```
> 不变性： 不可变对象(immutable object)一定是线程安全的。

当满足以下条件时，对象才是不可变的：
 - 对象创建以后其状态就不能修改；
 - 对象的所有域都是final类型(从技术上来看，不可变对象并不需要将其所有的域都声明为final类型，如String的hash域)；
 - 对象是正确创建的(在对象的创建时期，this 没有逸出)；
 ```java
     public int hashCode() { // hash的计算推迟到第一次调用hashCode(),基于final域value,每次计算结果都相同
        int h = hash; 
        if (h == 0 && value.length > 0) {
            char val[] = value;
            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
 ```

> final 域：final类型的域是不能修改的(但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的)。在java内存模型中，final域有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。

**"除非需要更高的可见性，否则应将所有的域都声明为私有域"是一个良好的编程习惯；"除非需要某个域是可变的,否则应将其声明为final域"也是一个良好的编程习惯。**






